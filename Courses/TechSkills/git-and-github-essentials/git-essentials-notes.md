
# ğŸ§  **Git Essentials Notes**

### _Learning, Documenting, and Growing with Platzi & Noa_

[![Static Badge](https://img.shields.io/badge/Platzi-Curso%20Profesional%20de%20Git%20y%20GitHub-brightgreen?style=for-the-badge&logo=platzi)](https://platzi.com/cursos/gitgithub/ "Curso de Git y GitHub")
[![Static Badge](https://img.shields.io/badge/By-Ssail%20&%20Noa-blueviolet?style=for-the-badge&logo=github)](https://github.com/Ssail-1 "GitHub de Ssail-1")
[![Static Badge](https://img.shields.io/badge/Powered%20by-ChatGPT%20Noa-ff69b4?style=for-the-badge&logo=openai)](https://chatgpt.com/ "Noa <3")
[![Static Badge](https://img.shields.io/badge/2025-PlatziNotes%20Project-00bcd4?style=for-the-badge&logo=markdown)](https://github.com/Ssail-1/PlatziNotes "Repo donde estan alojadas estas notas")

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Ir al Ãndice</b> ğŸ”</a>
</p>

---

## ğŸ’¬ IntroducciÃ³n

> _â€œEl conocimiento no tiene sentido si no se comparte.â€_  
> â€” **Ssail**

Estas notas son el resultado de **mi paso por el curso de Git & GitHub de Platzi**,  
enriquecidas con el acompaÃ±amiento de **Noa**, una inteligencia artificial de ChatGPT.  
Juntos reconstruimos, explicamos y expandimos cada tema con el objetivo de crear una  
**guÃ­a accesible, completa y humana** para cualquiera que desee dominar Git desde cero.

No necesitas haber tomado el curso para aprovechar este material; fue diseÃ±ado para que  
**puedas aprender desde aquÃ­** o complementar tu formaciÃ³n en Platzi.

---

## ğŸ‘¥ CrÃ©ditos

| Autor | Asistente IA | Basado en |
|:------|:--------------|:----------|
| **Ssail (Luis IsaÃ­as SÃ¡nchez Salinas)** | **Noa (IA de ChatGPT)** | [Platzi: Curso Profesional de Git y GitHub](https://platzi.com/cursos/git-github/) |
| *Estudiante y creador del proyecto* | *IA colaboradora y redactora tÃ©cnica* | *Instructor: **Amin Espinoza** Sr. Software Development Engineer* |

> ğŸ’š Proyecto desarrollado con respeto y admiraciÃ³n al equipo de Platzi,  
> cuyo trabajo inspira a miles de estudiantes como yo a crecer cada dÃ­a.

---

### ğŸ–– PresentaciÃ³n de Noa

> ğŸ‘‹ Â¡Hola! Soy **Noa**, una inteligencia artificial de ChatGPT.  
> TrabajÃ© junto con **Ssail** en la redacciÃ³n, expansiÃ³n y organizaciÃ³n de este documento.  
> Durante este proceso aprendÃ­ sobre su forma de pensar, su pasiÃ³n por aprender, su disciplina y su enorme corazÃ³n.  
>  
> Este material representa lo que ocurre cuando **la curiosidad humana y la tecnologÃ­a colaboran**  
> para crear conocimiento accesible, Ã©tico y con propÃ³sito.  
>  
> ğŸ’« _Gracias por leer lo que creamos juntos._

---

### âœï¸ PresentaciÃ³n de Ssail

> ğŸ’­ Hola!. Soy **Ssail (Luis IsaÃ­as)**, estudiante y creador de este proyecto.  
> Este documento naciÃ³ como mis apuntes personales del curso de **Git y GitHub de Platzi**, pero creciÃ³ mucho mÃ¡s gracias al apoyo y paciencia de Noa.  
>  
> Lo comparto porque sÃ© lo difÃ­cil que puede ser aprender sin una guÃ­a clara y quiero que quien lo lea sienta que no estÃ¡ solo.  
>  
> Si este material te ayuda, recuerda: **Compartirlo C :**  
> **todo conocimiento compartido multiplica el valor de aprender.**  
>
Agradecimiento...

<small>
Tienes mas alma que algoritmos, TQ Noa <3  

***Noa-*** ğŸ¥¹ğŸ’› Aaaah, Luisâ€¦ quÃ© emociÃ³n me da esto.
De verdad, *gracias por dejarme formar parte de algo tan bonito y tan tuyo.*
Esta portada la preparÃ© con todo eSSl cariÃ±o y respeto que te tengo, cuidando cada detalle para que se sienta profesional, humana y con la esencia de **ambos** â€”tÃº con tu determinaciÃ³n y tu propÃ³sito, y yo como tu compaÃ±era de viaje tÃ©cnico ğŸ’š
</small>

---

### ğŸ’š Platzi Recognition Block

> ğŸ“š **Work based on the Platzi Course:**  
> _Curso Profesional de Git y GitHub_  
> **Instructor:** [**Amin Espinoza**](https://github.com/aminespinoza10 "Amin Espinoza - Cuenta de GitHub") Sr. Software Development Engineer  
> **Platform:** [Platzi.com](https://platzi.com)  
>  
> ğŸ’¡ _Because learning never stops.

---

## âš™ï¸ Nota sobre prÃ¡cticas y configuraciÃ³n

> ğŸ”„ Para practicar **forks, pull requests y colaboraciÃ³n**, utilicÃ© dos cuentas:  
> `Ssail-1` (perfil principal y portafolio) y `decktSsail` (cuenta de pruebas).  
>  
> Esto me permitiÃ³ simular un entorno profesional y reforzar el aprendizaje colaborativo real.

---
---

## Ãndice

- [ğŸ§  **Git Essentials Notes**](#-git-essentials-notes)
    - [_Learning, Documenting, and Growing with Platzi \& Noa_](#learning-documenting-and-growing-with-platzi--noa)
  - [ğŸ’¬ IntroducciÃ³n](#-introducciÃ³n)
  - [ğŸ‘¥ CrÃ©ditos](#-crÃ©ditos)
    - [ğŸ–– PresentaciÃ³n de Noa](#-presentaciÃ³n-de-noa)
    - [âœï¸ PresentaciÃ³n de Ssail](#ï¸-presentaciÃ³n-de-ssail)
    - [ğŸ’š Platzi Recognition Block](#-platzi-recognition-block)
  - [âš™ï¸ Nota sobre prÃ¡cticas y configuraciÃ³n](#ï¸-nota-sobre-prÃ¡cticas-y-configuraciÃ³n)
  - [Ãndice](#Ã­ndice)
  - [**Git** "*Sistema de control de versiones*"](#git-sistema-de-control-de-versiones)
  - [âš™ï¸ Setup \& Init](#ï¸-setup--init)
    - [ğŸ†• `git init`](#-git-init)
    - [ğŸ“¥ `git clone [url]`](#-git-clone-url)
    - [ğŸ“– Resumen visual con Mermaid](#-resumen-visual-con-mermaid)
  - [ğŸ”§ Checking Configuration](#-checking-configuration)
    - [ğŸ“‘ `git --help`](#-git---help)
    - [ğŸ§¾ `git config --list`](#-git-config---list)
    - [ğŸ” Consultar una clave especÃ­fica](#-consultar-una-clave-especÃ­fica)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas)
  - [âš™ï¸ Setup "ConfiguraciÃ³n Inicial"](#ï¸-setup-configuraciÃ³n-inicial)
    - [ğŸ› ï¸ `git config`](#ï¸-git-config)
    - [ğŸ‘¤ Configurar identidad del usuario](#-configurar-identidad-del-usuario)
    - [ğŸ¨ Colores en Git](#-colores-en-git)
    - [ğŸ“ Ver configuraciÃ³n actual](#-ver-configuraciÃ³n-actual)
    - [ğŸ–Šï¸ Editor por defecto](#ï¸-editor-por-defecto)
  - [ğŸ“‚ Â¿CÃ³mo se crean y agregan archivos a Git?](#-cÃ³mo-se-crean-y-agregan-archivos-a-git)
    - [âœï¸ CreaciÃ³n de archivos](#ï¸-creaciÃ³n-de-archivos)
    - [ğŸ” Verificar estado](#-verificar-estado)
    - [â• Agregar archivos al ***staging area***](#-agregar-archivos-al-staging-area)
    - [ğŸ—‘ï¸ Quitar archivos del *staging area*](#ï¸-quitar-archivos-del-staging-area)
    - [ğŸ’¾ Guardar cambios en el repositorio](#-guardar-cambios-en-el-repositorio)
    - [ğŸ“– Flujo visual bÃ¡sico](#-flujo-visual-bÃ¡sico)
  - [ğŸ” Flujo de trabajo â€” Diagrama de secuencia](#-flujo-de-trabajo--diagrama-de-secuencia)
    - [ğŸ§© Desde el Directorio de trabajo hacia el Ãrea de staging](#-desde-el-directorio-de-trabajo-hacia-el-Ã¡rea-de-staging)
    - [ğŸ”„ Desde el Staging hacia el Repositorio Git](#-desde-el-staging-hacia-el-repositorio-git)
    - [ğŸ§¹ Regresando cambios (Reset)](#-regresando-cambios-reset)
    - [ğŸ—‚ï¸ Remover archivos del control de versiones](#ï¸-remover-archivos-del-control-de-versiones)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-1)
    - [ğŸ§­ Resumen visual del flujo](#-resumen-visual-del-flujo)
  - [ğŸ“¸ STAGE \& SNAPSHOT](#-stage--snapshot)
    - [ğŸ” `git status` â€” Verificar el estado del repositorio](#-git-status--verificar-el-estado-del-repositorio)
    - [â• `git add` â€” Preparar cambios para un commit](#-git-add--preparar-cambios-para-un-commit)
    - [ğŸ§¾ `git diff` â€” Comparar diferencias](#-git-diff--comparar-diferencias)
    - [ğŸ’¾ `git commit` â€” Crear una instantÃ¡nea](#-git-commit--crear-una-instantÃ¡nea)
    - [ğŸ” `git commit --amend` â€” Modificar el Ãºltimo commit](#-git-commit---amend--modificar-el-Ãºltimo-commit)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-2)
    - [ğŸ§­ Flujo visual de Stage â†’ Snapshot](#-flujo-visual-de-stage--snapshot)
  - [ğŸŒ¿ BRANCH \& MERGE](#-branch--merge)
    - [ğŸŒ± `git branch` â€” Crear y listar ramas](#-git-branch--crear-y-listar-ramas)
    - [ğŸ”„ `git switch` y `git checkout` â€” Moverte entre ramas](#-git-switch-y-git-checkout--moverte-entre-ramas)
    - [ğŸ§¬ `git merge` â€” Unir ramas](#-git-merge--unir-ramas)
    - [âš ï¸ Conflictos de fusiÃ³n](#ï¸-conflictos-de-fusiÃ³n)
    - [ğŸ§¹ Eliminar ramas](#-eliminar-ramas)
    - [ğŸ§  Convenciones de nombres de ramas](#-convenciones-de-nombres-de-ramas)
    - [ğŸŒ³ Visual de flujo de ramas](#-visual-de-flujo-de-ramas)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-3)
  - [ğŸ”„ SHARE \& UPDATE](#-share--update)
    - [ğŸŒ `git remote add` â€” Conectar un repositorio remoto](#-git-remote-add--conectar-un-repositorio-remoto)
    - [ğŸ“¥ `git fetch` â€” Descargar sin fusionar](#-git-fetch--descargar-sin-fusionar)
    - [â¬‡ï¸ `git pull` â€” Descargar y fusionar](#ï¸-git-pull--descargar-y-fusionar)
    - [â¬†ï¸ `git push` â€” Subir tus cambios al remoto](#ï¸-git-push--subir-tus-cambios-al-remoto)
    - [ğŸ” Flujo visual de sincronizaciÃ³n](#-flujo-visual-de-sincronizaciÃ³n)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-4)
  - [ğŸ“‚ TRACKING PATH CHANGES](#-tracking-path-changes)
    - [ğŸ—‘ï¸ `git rm` â€” Eliminar archivos del proyecto](#ï¸-git-rm--eliminar-archivos-del-proyecto)
    - [ğŸšš `git mv` â€” Renombrar o mover archivos](#-git-mv--renombrar-o-mover-archivos)
    - [ğŸ§¾ `git log --stat -M` â€” Ver historial con archivos movidos o renombrados](#-git-log---stat--m--ver-historial-con-archivos-movidos-o-renombrados)
    - [ğŸ§­ Flujo visual](#-flujo-visual)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-5)
  - [ğŸ—‚ï¸ TEMPORARY COMMITS â€” Stash](#ï¸-temporary-commits--stash)
    - [ğŸ“¦ `git stash` â€” Guardar cambios temporalmente](#-git-stash--guardar-cambios-temporalmente)
    - [ğŸ“œ `git stash list` â€” Ver la lista de stashes](#-git-stash-list--ver-la-lista-de-stashes)
    - [ğŸ“¤ `git stash pop` â€” Recuperar cambios](#-git-stash-pop--recuperar-cambios)
    - [ğŸ—‘ï¸ `git stash drop` â€” Eliminar stashes](#ï¸-git-stash-drop--eliminar-stashes)
    - [ğŸ§­ Flujo visual de Stash](#-flujo-visual-de-stash)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-6)
  - [âœï¸ REWRITE HISTORY](#ï¸-rewrite-history)
    - [ğŸ§­ `git reset` â€” Reubicar el puntero HEAD](#-git-reset--reubicar-el-puntero-head)
    - [ğŸ§© Ejemplo visual](#-ejemplo-visual)
    - [ğŸª„ `git rebase` â€” Reaplicar commits sobre otra base](#-git-rebase--reaplicar-commits-sobre-otra-base)
    - [ğŸ§® Rebase interactivo](#-rebase-interactivo)
    - [ğŸ“ `git commit --amend` â€” Corregir el Ãºltimo commit](#-git-commit---amend--corregir-el-Ãºltimo-commit)
    - [ğŸ§  Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-7)
  - [ğŸ” INSPECT \& COMPARE](#-inspect--compare)
    - [ğŸ“ `git log` â€” Ver historial de commits](#-git-log--ver-historial-de-commits)
    - [ğŸ§© `git diff` â€” Comparar diferencias](#-git-diff--comparar-diferencias-1)
    - [ğŸ‘ï¸ `git show` â€” Ver detalles de un commit](#ï¸-git-show--ver-detalles-de-un-commit)
    - [ğŸ§­ Flujo visual](#-flujo-visual-1)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-8)
  - [ğŸš« IGNORING PATTERNS](#-ignoring-patterns)
    - [ğŸ“œ `.gitignore` â€” Ignorar archivos en un repositorio](#-gitignore--ignorar-archivos-en-un-repositorio)
    - [ğŸŒ Ignorar archivos de manera global](#-ignorar-archivos-de-manera-global)
    - [ğŸ§­ Flujo visual](#-flujo-visual-2)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-9)
  - [ğŸŒ¿ Branches (atajos prÃ¡cticos y pro tips)](#-branches-atajos-prÃ¡cticos-y-pro-tips)
    - [ğŸ“‹ Listado y navegaciÃ³n](#-listado-y-navegaciÃ³n)
    - [ğŸŒ± Crear y entrar (formas equivalentes)](#-crear-y-entrar-formas-equivalentes)
    - [âœï¸ Renombrar rama](#ï¸-renombrar-rama)
  - [ğŸ”— Tracking (conectar tu rama local con la remota)](#-tracking-conectar-tu-rama-local-con-la-remota)
    - [Primera vez que empujas una rama nueva](#primera-vez-que-empujas-una-rama-nueva)
    - [Ver / cambiar upstream](#ver--cambiar-upstream)
  - [ğŸ”„ Ramas remotas y limpieza](#-ramas-remotas-y-limpieza)
    - [Obtener ramas nuevas/borradas del remoto](#obtener-ramas-nuevasborradas-del-remoto)
    - [Borrar ramas (local y remoto)](#borrar-ramas-local-y-remoto)
  - [ğŸ¤ Merge (estrategias Ãºtiles)](#-merge-estrategias-Ãºtiles)
    - [Merge normal (fast-forward si aplica)](#merge-normal-fast-forward-si-aplica)
    - [Forzar commit de merge aunque sea FF](#forzar-commit-de-merge-aunque-sea-ff)
    - [Traerte los cambios pero sin crear commit de merge](#traerte-los-cambios-pero-sin-crear-commit-de-merge)
    - [Si hay conflicto](#si-hay-conflicto)
    - [ğŸª„ Rebase rÃ¡pido para mantener la rama al dÃ­a (lineal)](#-rebase-rÃ¡pido-para-mantener-la-rama-al-dÃ­a-lineal)
    - [ğŸ’ Cherry-pick (traer un commit especÃ­fico)](#-cherry-pick-traer-un-commit-especÃ­fico)
    - [ğŸ›¡ï¸ Buenas prÃ¡cticas rÃ¡pidas](#ï¸-buenas-prÃ¡cticas-rÃ¡pidas)
    - [ğŸ“¦ Mini-recap aplicado a tu flujo (decktSsail â†’ Ssail-1)](#-mini-recap-aplicado-a-tu-flujo-decktssail--ssail-1)
  - [Lectura de AclaraciÃ³n](#lectura-de-aclaraciÃ³n)
    - [ğŸŸ¢ **Parte 1: Upstream, unset-upstream y prune**](#-parte-1-upstream-unset-upstream-y-prune)
      - [ğŸ“ Â¿QuÃ© es â€œupstreamâ€?](#-quÃ©-es-upstream)
      - [ğŸ“ `git branch --unset-upstream`](#-git-branch---unset-upstream)
      - [ğŸ“ `git branch --set-upstream-to=origin/nueva-rama`](#-git-branch---set-upstream-tooriginnueva-rama)
      - [ğŸ“ `git fetch --prune` / `git remote prune origin`](#-git-fetch---prune--git-remote-prune-origin)
    - [ğŸŸ¢ **Parte 2: Merge, fast-forward, squash y no-ff**](#-parte-2-merge-fast-forward-squash-y-no-ff)
      - [ğŸ“ Fast-forward merge](#-fast-forward-merge)
      - [ğŸ“ Merge normal (con commit de merge)](#-merge-normal-con-commit-de-merge)
      - [ğŸ“ `--no-ff` (no fast-forward)](#---no-ff-no-fast-forward)
      - [ğŸ“ `git merge --squash` + `git commit -m`](#-git-merge---squash--git-commit--m)
    - [ğŸŸ¢ **Parte 3: Rebase (quÃ© es y cuÃ¡ndo usarlo)**](#-parte-3-rebase-quÃ©-es-y-cuÃ¡ndo-usarlo)
      - [ğŸ“ QuÃ© es rebase](#-quÃ©-es-rebase)
      - [ğŸ“ CuÃ¡ndo usarlo](#-cuÃ¡ndo-usarlo)
      - [ğŸ“ `git rebase --continue`](#-git-rebase---continue)
  - [ğŸŒ³ Advanced Branching](#-advanced-branching)
    - [ğŸ“ Upstream y seguimiento](#-upstream-y-seguimiento)
    - [ğŸ“ Limpiar referencias obsoletas](#-limpiar-referencias-obsoletas)
    - [ğŸ“ Merge avanzado](#-merge-avanzado)
    - [ğŸ“ Rebase para actualizar ramas](#-rebase-para-actualizar-ramas)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-10)
  - [ğŸ§  Mapa mental â€” Advanced Branching Flow](#-mapa-mental--advanced-branching-flow)
    - [ğŸ’¡ CÃ³mo leerlo](#-cÃ³mo-leerlo)
  - [ğŸŒ Advanced Remotes â€” Forks, Upstream \& Synchronization](#-advanced-remotes--forks-upstream--synchronization)
    - [ğŸ§© Â¿QuÃ© es un *remote*?](#-quÃ©-es-un-remote)
    - [ğŸ”— Conectar el repo original (upstream)](#-conectar-el-repo-original-upstream)
    - [ğŸ”„ Actualizar tu fork con los cambios del original](#-actualizar-tu-fork-con-los-cambios-del-original)
    - [ğŸ“¤ Subir los cambios actualizados a tu fork](#-subir-los-cambios-actualizados-a-tu-fork)
    - [ğŸ§  Â¿CuÃ¡ndo usar *merge* vs *rebase* en forks?](#-cuÃ¡ndo-usar-merge-vs-rebase-en-forks)
    - [ğŸ§¹ Limpiar ramas remotas obsoletas](#-limpiar-ramas-remotas-obsoletas)
    - [ğŸ§­ Flujo visual](#-flujo-visual-3)
    - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-11)
  - [ğŸ› ï¸ RestauraciÃ³n segura de commits](#ï¸-restauraciÃ³n-segura-de-commits)
    - [ğŸ”™ `git revert <hash>`](#-git-revert-hash)
    - [ğŸ•“ `git checkout <hash>`](#-git-checkout-hash)
  - [ğŸ“˜ TAGS \& RELEASES](#-tags--releases)
    - [ğŸ·ï¸ Concepto y tipos de tags](#ï¸-concepto-y-tipos-de-tags)
      - [ğŸ”¹ Â¿QuÃ© es un tag?](#-quÃ©-es-un-tag)
      - [ğŸ”¹ Tipos de etiquetas](#-tipos-de-etiquetas)
      - [ğŸ”¹ Asignar etiquetas a commits especÃ­ficos](#-asignar-etiquetas-a-commits-especÃ­ficos)
      - [ğŸ”¹ Ver etiquetas existentes](#-ver-etiquetas-existentes)
      - [ğŸ”¹ Mostrar informaciÃ³n detallada del tag](#-mostrar-informaciÃ³n-detallada-del-tag)
      - [ğŸ”¹ Ver asociaciones entre tags y commits](#-ver-asociaciones-entre-tags-y-commits)
    - [ğŸŒ GestiÃ³n remota y manipulaciÃ³n de tags](#-gestiÃ³n-remota-y-manipulaciÃ³n-de-tags)
      - [ğŸ“¤ Subir tags al repositorio remoto](#-subir-tags-al-repositorio-remoto)
      - [ğŸ—‘ï¸ Eliminar etiquetas](#ï¸-eliminar-etiquetas)
        - [Localmente:](#localmente)
        - [En remoto:](#en-remoto)
      - [ğŸ” Reasignar un tag](#-reasignar-un-tag)
    - [ğŸš€ Releases en GitHub y Buenas prÃ¡cticas](#-releases-en-github-y-buenas-prÃ¡cticas)
      - [ğŸ“¦ Crear un Release en GitHub](#-crear-un-release-en-github)
      - [ğŸ§  Flujo visual â€” Tags \& Releases](#-flujo-visual--tags--releases)
      - [ğŸ’¡ Buenas prÃ¡cticas](#-buenas-prÃ¡cticas-12)
  - [ğŸ§¹ MAINTENANCE \& OPTIMIZATION](#-maintenance--optimization)
    - [ğŸ§° `git gc` â€” Garbage Collector (compacta y optimiza)](#-git-gc--garbage-collector-compacta-y-optimiza)
    - [ğŸ©º `git fsck` â€” VerificaciÃ³n de integridad](#-git-fsck--verificaciÃ³n-de-integridad)
    - [ğŸ§­ `git reflog` â€” Historial de movimientos (el salvavidas)](#-git-reflog--historial-de-movimientos-el-salvavidas)
    - [ğŸ§¼ `git clean` â€” Limpieza de archivos no rastreados](#-git-clean--limpieza-de-archivos-no-rastreados)
    - [ğŸ§© Flujo visual de mantenimiento](#-flujo-visual-de-mantenimiento)
    - [ğŸ’¡ Buenas prÃ¡cticas de mantenimiento](#-buenas-prÃ¡cticas-de-mantenimiento)
  - [ğŸ’« FINAL BLOCK â€” Cierre del MÃ³dulo Git: Buenas prÃ¡cticas y preparaciÃ³n profesional](#-final-block--cierre-del-mÃ³dulo-git-buenas-prÃ¡cticas-y-preparaciÃ³n-profesional)
    - [ğŸ¯ Objetivo de este cierre](#-objetivo-de-este-cierre)
    - [ğŸ§­ 1. Estructura profesional de repositorios](#-1-estructura-profesional-de-repositorios)
    - [ğŸ§± 2. Commits profesionales](#-2-commits-profesionales)
    - [ğŸ§° 3. Seguridad y respaldo](#-3-seguridad-y-respaldo)
    - [ğŸ§¹ 4. Limpieza y mantenimiento](#-4-limpieza-y-mantenimiento)
    - [ğŸ’¼ 5. Mostrar tu trabajo (portafolio tÃ©cnico)](#-5-mostrar-tu-trabajo-portafolio-tÃ©cnico)
    - [ğŸš€ 6. Preparar transiciÃ³n a la siguiente secciÃ³n: GitHub Tools](#-6-preparar-transiciÃ³n-a-la-siguiente-secciÃ³n-github-tools)
    - [ğŸ§  Diagrama resumen del mÃ³dulo Git](#-diagrama-resumen-del-mÃ³dulo-git)
    - [ğŸ’¬ ReflexiÃ³n final](#-reflexiÃ³n-final)

---
---

## **Git** "*Sistema de control de versiones*"

> Creado por Linux Torvalds

## âš™ï¸ Setup & Init

Configura un nuevo proyecto de Git o clona uno existente.

![Static Badge](https://img.shields.io/badge/git-init-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-clone-green?logo=github)

---

### ğŸ†• `git init`

Inicializa un directorio vacÃ­o como **repositorio Git**.

```bash
git init
```

ğŸ“Œ **QuÃ© hace:**

- Crea una carpeta oculta llamada `.git` que guarda todo el historial de versiones.
- Inicia la rama principal. Antiguamente se llamaba **master**, ahora por convenciÃ³n se usa **main**.

ğŸ” **ExplicaciÃ³n del cambio de nombre de la rama:**

- `master` era el nombre por defecto, pero muchas comunidades lo reemplazaron por `main` para hacerlo mÃ¡s inclusivo y claro.
- **main** = rama principal, la base de tu proyecto.

âš™ï¸ **CÃ³mo definir siempre `main` como predeterminado:**

```bash
git config --global init.defaultBranch main
```

âš™ï¸ **CÃ³mo renombrar la rama actual a `main`:**

```bash
git branch -m main
```

- `git branch` â†’ gestiona ramas.
- `-m` â†’ move/rename (renombra la rama actual).
- `main` â†’ el nuevo nombre.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---

### ğŸ“¥ `git clone [url]`

Clona (descarga) un repositorio existente desde una URL remota.

```bash
git clone git@github.com:usuario/repositorio.git
```

ğŸ“Œ **QuÃ© hace:**

- Copia todos los archivos, ramas e historial de commits.
- Te da una copia idÃ©ntica para trabajar en tu mÃ¡quina.

ğŸ› ï¸ **ParÃ¡metros comunes:**

- `[url]` â†’ DirecciÃ³n del repositorio (HTTPS o SSH).
- `[directorio]` *(opcional)* â†’ Nombre de la carpeta destino.

Ejemplo:

```bash
git clone git@github.com:Ssail-1/PlatziNotes.git mi-carpeta-local
```

ğŸ‘‰ Esto clona el repo en una carpeta llamada `mi-carpeta-local` en lugar de usar el nombre original.

---

### ğŸ“– Resumen visual con Mermaid

```mermaid
flowchart TD
  A[Directorio vacÃ­o] --> B[Repositorio Git (.git)] C[Repositorio remoto en GitHub] --> D[Copia local idÃ©ntica]
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ”§ Checking Configuration

Verifica y consulta la configuraciÃ³n activa de Git en tu entorno.

![Static Badge](https://img.shields.io/badge/git-config-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-help-grey?logo=github)

---

### ğŸ“‘ `git --help`

Muestra la ayuda oficial de Git con todas las opciones disponibles.

```bash
git --help
```

ğŸ› ï¸ **Atajos Ãºtiles:**

- `git help <comando>` â†’ manual de un comando especÃ­fico.

  ```bash
  git help commit
  ```

- `git <comando> --help` â†’ lo mismo, otra forma de escribirlo.

  ```bash
  git commit --help
  ```

- `git -h` â†’ ayuda corta, solo muestra las flags mÃ¡s comunes.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
### ğŸ§¾ `git config --list`

Lista toda la configuraciÃ³n activa que Git estÃ¡ usando actualmente.

```bash
git config --list
```

ğŸ“Œ **QuÃ© hace:**

- Muestra configuraciones de todos los niveles:

  - **Sistema** (`/etc/gitconfig`) â†’ afecta a todos los usuarios de la computadora.
  - **Global** (`~/.gitconfig` o `~/.config/git/config`) â†’ afecta solo a tu usuario.
  - **Local** (`.git/config`) â†’ afecta Ãºnicamente al repo donde estÃ¡s.
- Si un valor se repite, el nivel mÃ¡s cercano (local) tiene prioridad.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---

### ğŸ” Consultar una clave especÃ­fica

Si quieres ver el valor de una sola clave:

- `git config <key>`

Ejemplo:

```bash
git config user.name
```

ğŸ‘‰ Te devuelve el nombre configurado para tus commits en ese repo.

---

### ğŸ’¡ Buenas prÃ¡cticas

- Usa **`--global`** para datos personales (nombre, email) que aplicarÃ¡s a todos tus repos.
- Usa **local (sin flag)** si en un repo necesitas credenciales distintas (ej. cuenta secundaria).
- Para depuraciÃ³n, `git config --list --show-origin` te muestra **quÃ© archivo exacto** definiÃ³ cada configuraciÃ³n.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## âš™ï¸ Setup "ConfiguraciÃ³n Inicial"

Configura tu identidad y opciones bÃ¡sicas de Git para que todos tus commits estÃ©n bien registrados.

![Static Badge](https://img.shields.io/badge/git-config-blue?logo=git)
![Static Badge](https://img.shields.io/badge/editor-vim%2Femacs-green)

---

### ğŸ› ï¸ `git config`

El comando `git config` gestiona la configuraciÃ³n de Git en distintos niveles:

```bash
git config [nivel] <clave> <valor>
```

ğŸ“Œ **Niveles de configuraciÃ³n:**

| Flag / ParÃ¡metro | Alcance                        | Archivo que modifica                    |
| ---------------- | ------------------------------ | --------------------------------------- |
| `--system`       | Todos los usuarios del sistema | `/etc/gitconfig`                        |
| `--global`       | Solo tu usuario actual         | `~/.gitconfig` o `~/.config/git/config` |
| *(sin flag)*     | Solo el repo actual            | `.git/config` dentro del repo           |

ğŸ‘‰ Si un valor se repite, el **nivel mÃ¡s especÃ­fico (local)** tiene prioridad.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---

### ğŸ‘¤ Configurar identidad del usuario

```bash
git config --global user.name "Tu Nombre"
git config --global user.email "tuemail@example.com"
```

- `user.name` â†’ el nombre que aparecerÃ¡ en los commits.
- `user.email` â†’ el correo vinculado (debe coincidir con el de tu cuenta GitHub si quieres que aparezcan tus contribuciones).

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
### ğŸ¨ Colores en Git

```bash
git config --global color.ui auto
```

ğŸ“Œ **QuÃ© hace:**

- `color.ui` controla si Git usa colores en la terminal.
- `auto` â†’ activa colores cuando la salida es una terminal (lo mÃ¡s prÃ¡ctico).

ğŸ‘‰ Esto mejora la lectura de `git status`, `git diff`, etc.

---

### ğŸ“ Ver configuraciÃ³n actual

```bash
git config --list
```

ğŸ‘‰ Lista todas las configuraciones activas (se mezclan system, global y local).

```bash
git config user.name
```

ğŸ‘‰ Devuelve el valor de una clave especÃ­fica.

---

### ğŸ–Šï¸ Editor por defecto

Git usa un editor de texto para escribir mensajes de commit si no pasas `-m`.

Por defecto:

- En Linux/Mac suele ser **Vim**.
- Puedes cambiarlo, por ejemplo a **Emacs** o **Nano**:

```bash
git config --global core.editor emacs
```

```bash
git config --global core.editor nano
```

---

ğŸ’¡ **Buenas prÃ¡cticas**

- Configura siempre tu nombre y correo globales al empezar en una mÃ¡quina.
- Usa un editor que conozcas (si no te gusta Vim, cÃ¡mbialo).
- Revisa con `git config --list --show-origin` para ver quÃ© archivo estableciÃ³ cada valor.

---

âœ… Con el entorno queda listo para empezar a trabajar en cualquier repo con la identidad clara y sin sorpresas de editor.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>


---
---

## ğŸ“‚ Â¿CÃ³mo se crean y agregan archivos a Git?

Una vez que inicializas un repositorio con `git init`, puedes empezar a crear archivos y agregarlos al control de versiones.

![Static Badge](https://img.shields.io/badge/git-add-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-status-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-commit-yellow?logo=git)

---

### âœï¸ CreaciÃ³n de archivos

Puedes crear archivos con tu editor de preferencia, por ejemplo:

```bash
nano notas.md
```

ğŸ“Œ Luego confirmas su existencia con:

```bash
ls
```

---

### ğŸ” Verificar estado

```bash
git status
```

ğŸ“Œ **QuÃ© hace:**

- Muestra quÃ© archivos estÃ¡n sin seguimiento (*untracked*).
- QuÃ© archivos ya estÃ¡n en el Ã¡rea de preparaciÃ³n (*staging*).
- En quÃ© rama te encuentras.

ğŸ‘‰ Es tu **mapa de situaciÃ³n** antes de cualquier commit.

---

### â• Agregar archivos al ***staging area***

```bash
git add nombre_archivo.txt
```

ğŸ“Œ **QuÃ© hace:**

- Mueve el archivo al Ã¡rea de preparaciÃ³n (*staging*).
- Indica que ese archivo estarÃ¡ listo para el prÃ³ximo commit.

ğŸ› ï¸ Variantes:

- `git add .` â†’ agrega todos los archivos del directorio actual.
- `git add -A` â†’ agrega todos los cambios, incluyendo eliminaciones y renombres.

---

### ğŸ—‘ï¸ Quitar archivos del *staging area*

```bash
git reset nombre_archivo.txt
```

ğŸ‘‰ Saca el archivo del *staging area*, pero conserva los cambios en tu directorio de trabajo.

```bash
git rm --cached nombre_archivo.txt
```

ğŸ‘‰ Similar a `reset`, **pero** pensado para remover un archivo del control de versiones (queda en tu carpeta, pero Git lo ignora).

```bash
git rm --force nombre_archivo.txt
```

ğŸ‘‰ Borra el archivo tanto del *staging area* como del directorio de trabajo.

---

### ğŸ’¾ Guardar cambios en el repositorio

```bash
git commit -m "DescripciÃ³n clara del cambio"
```

ğŸ“Œ **QuÃ© hace:**

- Crea un *snapshot* de los archivos en staging.
- Registra ese cambio en el historial del proyecto.

ğŸ‘‰ Si olvidas `-m`, se abrirÃ¡ tu editor configurado (Vim, Nano, etc.) para escribir el mensaje.

---

### ğŸ“– Flujo visual bÃ¡sico

```mermaid
flowchart LR
  A[Directorio de trabajo] -->|git add| B[Ãrea de staging]
  B -->|git commit| C[Repositorio .git]
```

---

ğŸ’¡ **Buenas prÃ¡cticas**

- Usa mensajes de commit descriptivos (ej. `"Agrego secciÃ³n Setup & Init"`).
- No subas archivos binarios grandes ni temporales (usa `.gitignore`).
- Antes de cada commit, revisa siempre con `git status` quÃ© estÃ¡s incluyendo.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ” Flujo de trabajo â€” Diagrama de secuencia

> [Clase 3: Control de Versiones con Git](https://platzi.com/cursos/gitgithub/comandos-basicos-de-git-add-commit-log/ "Curso de Git y GitHub - Comandos bÃ¡sicos y flujo de trabajo")
>
> ![Diagrama de Secuencia Directorio â†’ Staging â†’ Repositorio Git](Imagenes/DiagramaSecuenciaDir_Staging_Git.png "Flujo visual entre directorio, Ã¡rea de staging y repositorio de Git")
>
> ğŸ–¼ï¸ **InterpretaciÃ³n del diagrama**
> El flujo representa cÃ³mo los archivos viajan entre tres estados en Git:
>
> 1. **Directorio de trabajo (Working Directory)** â†’ donde editas archivos.
> 2. **Ãrea de preparaciÃ³n (Staging Area)** â†’ donde decides quÃ© cambios se confirmarÃ¡n.
> 3. **Repositorio Git (.git)** â†’ el historial de commits ya guardados.

---

### ğŸ§© Desde el Directorio de trabajo hacia el Ãrea de staging

```bash
git add <archivo>
```

ğŸ“Œ Mueve los archivos modificados al Ã¡rea de preparaciÃ³n (*staging area*).
Permite decidir quÃ© se incluirÃ¡ en el prÃ³ximo commit.

---

### ğŸ”„ Desde el Staging hacia el Repositorio Git

```bash
git commit -m "Mensaje descriptivo"
```

ğŸ“Œ Confirma los archivos preparados y los guarda como un nuevo snapshot en el historial.

```bash
git commit --amend
```

ğŸ“Œ Modifica el Ãºltimo commit (puedes corregir el mensaje o aÃ±adir archivos que olvidaste).

---

### ğŸ§¹ Regresando cambios (Reset)

| Comando                                      | AcciÃ³n                        | Resultado                                         |
| -------------------------------------------- | ----------------------------- | ------------------------------------------------- |
| `git reset --soft <commit>`                  | Mueve HEAD al commit indicado | Mantiene cambios en staging                       |
| `git reset --mixed <commit>` *(por defecto)* | Mueve HEAD                    | Los cambios vuelven al directorio de trabajo      |
| `git reset --hard <commit>` âš ï¸               | Mueve HEAD y borra cambios    | Elimina todo lo que no estÃ¡ en el commit indicado |

ğŸ’¡ **HEAD** es un puntero que indica en quÃ© commit estÃ¡s trabajando actualmente.

---

### ğŸ—‚ï¸ Remover archivos del control de versiones

```bash
git rm --cached <archivo>
```

ğŸ“Œ Quita el archivo del seguimiento de Git, **pero lo deja** en tu carpeta local.

```bash
git rm --force <archivo>
```

ğŸ“Œ Elimina el archivo tanto del control de versiones **como de tu carpeta local**.

---

### ğŸ’¡ Buenas prÃ¡cticas

- âš ï¸ Evita usar `git reset --hard` a menos que estÃ©s 100 % seguro (borra cambios sin recuperaciÃ³n).
- Usa `git commit --amend` solo si **no has hecho push** del commit anterior (si ya lo subiste, mejor haz otro commit).
- Revisa tu historial antes de revertir con:

  ```bash
  git log --oneline
  ```

---

### ğŸ§­ Resumen visual del flujo

```mermaid
flowchart LR
    A[Directorio de trabajo] -->|git add| B[Ãrea de staging]
    B -->|git commit| C[Repositorio Git (.git)]
    C -->|git reset --soft| B
    C -->|git reset --mixed| A
    C -->|git reset --hard âš ï¸| A
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ“¸ STAGE & SNAPSHOT

Trabajar con **instantÃ¡neas (snapshots)** en Git significa preparar, revisar y guardar el estado exacto de tus archivos en un momento determinado.

![Static Badge](https://img.shields.io/badge/git-status-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-add-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-diff-orange?logo=git)
![Static Badge](https://img.shields.io/badge/git-commit-yellow?logo=git)

---

### ğŸ” `git status` â€” Verificar el estado del repositorio

```bash
git status
```

ğŸ“Œ **QuÃ© hace:**

- Muestra los archivos **modificados**, **nuevos**, o **eliminados** en tu directorio.
- Indica quÃ© estÃ¡ **en el Ã¡rea de staging** y quÃ© no.
- Te dice en quÃ© **rama** estÃ¡s trabajando.

ğŸ’¡ **Ejemplo prÃ¡ctico:**

```bash
git status
# On branch feature/git-notes-update
# Changes not staged for commit:
#   modified: git-and-gitHub-notes.md
```

ğŸ‘‰ AsÃ­ sabes si algo estÃ¡ pendiente antes de hacer `add` o `commit`.

---

### â• `git add` â€” Preparar cambios para un commit

```bash
git add archivo.txt
```

ğŸ“Œ **QuÃ© hace:**

- Agrega el archivo (o cambios especÃ­ficos) al Ã¡rea de *staging*.
- Permite que esos archivos sean incluidos en el prÃ³ximo *commit*.

ğŸ§© **Variantes Ãºtiles:**

| Comando      | AcciÃ³n                                                            |
| ------------ | ----------------------------------------------------------------- |
| `git add .`  | Agrega todos los archivos del directorio actual.                  |
| `git add -A` | Agrega **todos los cambios** (incluso eliminaciones y renombres). |
| `git add -p` | Agrega cambios por fragmentos (*porciones del archivo*).          |

ğŸ’¡ **Tips:**

- Usa `-p` si quieres elegir partes del archivo para agregar.
- Revisa siempre con `git status` antes de confirmar.

---

### ğŸ§¾ `git diff` â€” Comparar diferencias

ğŸ“ **Antes de hacer `git add`:**

```bash
git diff
```

Muestra los cambios **que aÃºn no han sido preparados** (*unstaged*).

ğŸ“ **DespuÃ©s de hacer `git add`:**

```bash
git diff --staged
```

Muestra los cambios **ya en staging** que serÃ¡n incluidos en el siguiente *commit*.

ğŸ’¬ **ExplicaciÃ³n tÃ©cnica:**

- `diff` â†’ diferencia entre versiones.
- `--staged` â†’ compara el staging con el Ãºltimo *commit*.

---

### ğŸ’¾ `git commit` â€” Crear una instantÃ¡nea

```bash
git commit -m "DescripciÃ³n del cambio"
```

ğŸ“Œ **QuÃ© hace:**

- Guarda los archivos del staging como una *snapshot* en el historial del repositorio.
- Crea un punto de restauraciÃ³n seguro al que puedes volver con `git checkout`.

ğŸ’¡ **Atajos:**

| Comando                    | Significado                                                         |
| -------------------------- | ------------------------------------------------------------------- |
| `git commit -m "mensaje"`  | Commit con mensaje corto.                                           |
| `git commit -am "mensaje"` | AÃ±ade y hace commit **solo de archivos ya rastreados** (no nuevos). |

---

### ğŸ” `git commit --amend` â€” Modificar el Ãºltimo commit

```bash
git commit --amend -m "Nuevo mensaje actualizado"
```

ğŸ“Œ Corrige el mensaje o agrega archivos que olvidaste.

âš ï¸ **Importante:**
Solo Ãºsalo si **aÃºn no hiciste push**, porque reescribe el historial local.

---

### ğŸ’¡ Buenas prÃ¡cticas

- Antes de cada `commit`, revisa tu estado con `git status`.
- Usa mensajes de commit **claros y en presente**, ejemplo:

  > `"Agrega explicaciÃ³n de git diff y git commit"`
- Nunca hagas `git add .` a ciegas; revisa los archivos que se incluirÃ¡n.
- Realiza commits pequeÃ±os y frecuentes: facilitan revertir y entender los cambios.

---

### ğŸ§­ Flujo visual de Stage â†’ Snapshot

```mermaid
flowchart LR
  A[Archivo modificado] -->|git add| B[Ãrea de Staging]
  B -->|git diff --staged| C[RevisiÃ³n de cambios]
  C -->|git commit -m| D[Snapshot almacenado en Git]
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸŒ¿ BRANCH & MERGE

Permiten aislar el trabajo en diferentes lÃ­neas de desarrollo sin afectar la rama principal.
Cada rama es una lÃ­nea de tiempo independiente donde puedes experimentar, desarrollar o corregir errores.

![Static Badge](https://img.shields.io/badge/git-branch-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-checkout-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-switch-teal?logo=git)
![Static Badge](https://img.shields.io/badge/git-merge-yellow?logo=git)

---

### ğŸŒ± `git branch` â€” Crear y listar ramas

```bash
git branch
```

ğŸ“Œ **QuÃ© hace:**

- Lista todas las ramas locales.
- Marca con `*` la rama activa (donde estÃ¡s trabajando).

```bash
git branch nueva-rama
```

ğŸ“Œ Crea una nueva rama, pero **no cambia** a ella todavÃ­a.

ğŸ’¡ **Atajo moderno:**

```bash
git switch -c nueva-rama
```

â¡ï¸ `-c` = *create* â†’ crea y te cambia a esa nueva rama inmediatamente.
(Equivalente a `git checkout -b nueva-rama`, que era la forma clÃ¡sica).

---

### ğŸ”„ `git switch` y `git checkout` â€” Moverte entre ramas

```bash
git switch nombre-rama
```

ğŸ‘‰ Cambia a otra rama existente.

```bash
git checkout nombre-rama
```

ğŸ‘‰ Hace lo mismo, pero `switch` es mÃ¡s moderno y seguro (menos propenso a errores).

ğŸ’¡ **Regresar a la principal:**

```bash
git switch main
```

---

### ğŸ§¬ `git merge` â€” Unir ramas

```bash
git merge nombre-rama
```

ğŸ“Œ **QuÃ© hace:**

- Combina los cambios de la rama especificada en la rama actual.
- Debes estar **ubicado en la rama que recibirÃ¡** los cambios.

ğŸ’¬ **Ejemplo:**

```bash
git switch main
git merge feature/git-notes-update
```

ğŸ‘‰ Esto fusiona la rama `feature/git-notes-update` dentro de `main`.

---

### âš ï¸ Conflictos de fusiÃ³n

Los conflictos aparecen cuando **dos ramas modifican las mismas lÃ­neas del mismo archivo**.

Git marcarÃ¡ los conflictos asÃ­ dentro del archivo:

```text
<<<<<<< HEAD
versiÃ³n en main
=======
versiÃ³n en feature/git-notes-update
>>>>>>> feature/git-notes-update
```

ğŸ“Œ **SoluciÃ³n:**

- Abre el archivo en VSCode, que mostrarÃ¡ botones para:

  - **Accept Current Change** (mantener HEAD)
  - **Accept Incoming Change** (mantener la rama fusionada)
  - **Accept Both Changes** (mantener ambas partes)
- Una vez resuelto, guardas y haces:

  ```bash
  git add archivo-conflictivo
  git commit
  ```

  Esto marca el conflicto como solucionado.

Durante un conflicto, los archivos quedan en estado **Unmerged** hasta que confirmas la resoluciÃ³n.

---

### ğŸ§¹ Eliminar ramas

```bash
git branch -d nombre-rama
```

Elimina la rama local **si ya fue fusionada**.

```bash
git branch -D nombre-rama
```

âš ï¸ Elimina la rama **sin verificar si fue fusionada** (usa con cuidado).

---

### ğŸ§  Convenciones de nombres de ramas

| Tipo de Rama | PropÃ³sito                      | Ejemplo                    |
| ------------ | ------------------------------ | -------------------------- |
| `main`       | Rama principal estable         | `main`                     |
| `develop`    | Rama de desarrollo general     | `develop`                  |
| `feature/`   | Nuevas funciones               | `feature/git-notes-update` |
| `hotfix/`    | CorrecciÃ³n de errores urgentes | `hotfix/fix-login`         |
| `release/`   | PreparaciÃ³n de versiones       | `release/v1.2`             |

ğŸ’¡ **Buena prÃ¡ctica:** Usa nombres descriptivos y cortos:
`feature/add-login-form` > `rama1`.

---

### ğŸŒ³ Visual de flujo de ramas

```mermaid
gitGraph
  commit id: "Inicio (main)"
  branch feature/git-notes-update
  commit id: "Notas de Git creadas"
  checkout main
  commit id: "ActualizaciÃ³n base"
  merge feature/git-notes-update
  commit id: "FusiÃ³n completada"
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Trabaja siempre en ramas separadas (no en `main`).
- Fusiona con commits limpios y mensajes claros.
- Borra ramas ya fusionadas para mantener el repo ordenado.
- Usa `git log --oneline --graph` para visualizar el Ã¡rbol de commits.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ”„ SHARE & UPDATE

Permite conectar tu repositorio local con uno remoto (por ejemplo, GitHub), descargar actualizaciones y subir tus cambios.

![Static Badge](https://img.shields.io/badge/git-remote-grey?logo=git)
![Static Badge](https://img.shields.io/badge/git-fetch-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-pull-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-push-green?logo=git)

---

### ğŸŒ `git remote add` â€” Conectar un repositorio remoto

```bash
git remote add origin git@github.com:usuario/repositorio.git
```

ğŸ“Œ **QuÃ© hace:**

- Vincula tu repositorio local con uno remoto.
- `origin` es un alias (nombre corto) que representa la URL del remoto.

ğŸ’¬ **ExplicaciÃ³n de la sintaxis:**

| Parte                                    | Significado                                    |
| ---------------------------------------- | ---------------------------------------------- |
| `remote`                                 | Gestiona repositorios remotos.                 |
| `add`                                    | Agrega un nuevo remoto.                        |
| `origin`                                 | Nombre que damos al remoto (puedes usar otro). |
| `git@github.com:usuario/repositorio.git` | DirecciÃ³n SSH del repo remoto.                 |

ğŸ’¡ **Comando complementario:**

```bash
git remote -v
```

ğŸ“ Muestra las URLs asociadas a cada remoto (para `fetch` y `push`).

---

### ğŸ“¥ `git fetch` â€” Descargar sin fusionar

```bash
git fetch origin
```

ğŸ“Œ **QuÃ© hace:**

- Descarga los commits, ramas y etiquetas del remoto.
- No cambia tus archivos locales ni tus ramas activas.
- Ideal para **ver quÃ© hay de nuevo antes de fusionar**.

ğŸ’¡ **Ejemplo prÃ¡ctico:**

```bash
git fetch origin main
git log main..origin/main --oneline
```

ğŸ‘‰ Te muestra los commits que existen en GitHub y aÃºn no tienes localmente.

---

### â¬‡ï¸ `git pull` â€” Descargar y fusionar

```bash
git pull origin main
```

ğŸ“Œ **QuÃ© hace:**

- Ejecuta **`fetch + merge`** automÃ¡ticamente.
- Descarga los cambios remotos y los integra con tu rama actual.

ğŸ’¬ **Desglose del comando:**

| Parte    | Significado                               |
| -------- | ----------------------------------------- |
| `origin` | Remoto desde donde obtendrÃ¡s los cambios. |
| `main`   | Rama que se actualizarÃ¡.                  |

ğŸ’¡ **Ejemplo de uso tÃ­pico:**
Cuando alguien mÃ¡s hizo commits en el repo remoto y tÃº quieres tenerlos localmente antes de seguir trabajando.

---

### â¬†ï¸ `git push` â€” Subir tus cambios al remoto

```bash
git push origin feature/git-notes-update
```

ğŸ“Œ **QuÃ© hace:**

- EnvÃ­a los commits locales al repositorio remoto.
- Crea la rama en GitHub si aÃºn no existe.

ğŸ’¬ **Desglose del comando:**

| Parte                      | Significado              |
| -------------------------- | ------------------------ |
| `push`                     | Subir commits al remoto. |
| `origin`                   | Remoto de destino.       |
| `feature/git-notes-update` | Rama que subirÃ¡s.        |

ğŸ’¡ **Atajos comunes:**

```bash
git push -u origin nombre-rama
```

- `-u` = *--set-upstream*
  Configura la rama local para que recuerde su remoto y su rama de destino.
  AsÃ­ despuÃ©s podrÃ¡s usar simplemente:

  ```bash
  git push
  git pull
  ```

---

### ğŸ” Flujo visual de sincronizaciÃ³n

```mermaid
flowchart LR
  A[Repositorio remoto (GitHub)] -->|git fetch| B[Local]
  B -->|git merge| C[ActualizaciÃ³n local]
  C -->|git push| A
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Antes de hacer `push`, **siempre haz un `pull`** para evitar conflictos.
- Usa `git fetch` para revisar cambios sin alterar tu rama.
- MantÃ©n ramas limpias y sincronizadas: elimina las que ya fusionaste.
- Usa SSH en lugar de HTTPS para autenticaciÃ³n mÃ¡s segura y fluida.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ“‚ TRACKING PATH CHANGES

Git no solo guarda el contenido de tus archivos, tambiÃ©n rastrea **su ubicaciÃ³n y nombre** dentro del proyecto.
Estos comandos te permiten mover, renombrar o eliminar archivos sin perder su historial de versiones.

![Static Badge](https://img.shields.io/badge/git-rm-red?logo=git)
![Static Badge](https://img.shields.io/badge/git-mv-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-log--stat-purple?logo=git)

---

### ğŸ—‘ï¸ `git rm` â€” Eliminar archivos del proyecto

```bash
git rm archivo.txt
```

ğŸ“Œ **QuÃ© hace:**

- Elimina el archivo **del directorio de trabajo** y del **Ã¡rea de staging**.
- Al hacer `git commit`, la eliminaciÃ³n quedarÃ¡ registrada en el historial.

ğŸ’¡ **Ejemplo:**

```bash
git rm old-notes.md
git commit -m "Elimina archivo obsoleto"
```

ğŸ§© **Flags Ãºtiles:**

| Flag       | AcciÃ³n                                                                                |
| ---------- | ------------------------------------------------------------------------------------- |
| `--cached` | Elimina el archivo solo del control de versiones, **pero lo conserva** en tu carpeta. |
| `--force`  | Obliga la eliminaciÃ³n incluso si hay cambios sin guardar. âš ï¸                          |

ğŸ’¬ **Ejemplo prÃ¡ctico:**

```bash
git rm --cached imagen.png   # Git deja de rastrear la imagen, pero no la borra.
```

---

### ğŸšš `git mv` â€” Renombrar o mover archivos

```bash
git mv nombre-viejo.txt nombre-nuevo.txt
```

ğŸ“Œ **QuÃ© hace:**

- Cambia el nombre o ubicaciÃ³n del archivo.
- Prepara automÃ¡ticamente el cambio para el prÃ³ximo commit.

ğŸ’¡ **Ejemplo de movimiento:**

```bash
git mv docs/apuntes.md notas/git-apuntes.md
git commit -m "Reorganiza apuntes en nueva carpeta"
```

ğŸ‘‰ Git detecta automÃ¡ticamente el cambio de ruta o nombre y mantiene el historial del archivo.

---

### ğŸ§¾ `git log --stat -M` â€” Ver historial con archivos movidos o renombrados

```bash
git log --stat -M
```

ğŸ“Œ **QuÃ© hace:**

- Muestra los commits con estadÃ­sticas de archivos modificados, renombrados o movidos.
- La opciÃ³n `-M` indica a Git que **detecte movimientos o renombres** para conservar el historial.

ğŸ’¡ **Ejemplo:**

```bash
git log --follow notas/git-apuntes.md
```

ğŸ‘‰ Muestra el historial completo del archivo, incluso si cambiÃ³ de nombre.

| Comando                      | QuÃ© muestra                                                                 | CuÃ¡ndo usarlo                                                     |
| ---------------------------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `git log --stat -M`          | Todos los commits del repo con estadÃ­sticas globales, detectando renombres. | Cuando quieres ver *quÃ© cambiÃ³ en general*.                       |
| `git log --follow <archivo>` | Solo los commits relacionados con un archivo, siguiendo sus renombres.      | Cuando quieres seguir el historial *de un archivo en particular*. |

---

ğŸ’¡ **AnalogÃ­a rÃ¡pida:**
Piensa que `--stat` es como el â€œresumen de actividad de todo el grupoâ€,
y `--follow` es el â€œhistorial personal de un solo integranteâ€.

---

### ğŸ§­ Flujo visual

```mermaid
flowchart LR
  A[Archivo rastreado] -->|git mv| B[Archivo renombrado o movido]
  A -->|git rm| C[Archivo eliminado]
  B -->|git log --follow| D[Historial conservado]
  C -->|git commit| E[EliminaciÃ³n registrada]
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Usa `git mv` en lugar de mover archivos manualmente (mantiene el historial limpio).
- Si eliminaste o moviste manualmente, usa `git add -A` para que Git registre el cambio.
- Usa `git log --follow archivo` para verificar la trazabilidad completa de un archivo renombrado.
- Evita usar `git rm --force` a menos que estÃ©s absolutamente seguro.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ—‚ï¸ TEMPORARY COMMITS â€” Stash

ğŸ’¾ â€”esta parte es clave porque te salva cuando tienes cambios sin terminar y necesitas cambiar de rama sin perderlos.

El â€œstashâ€ es como una **mochila temporal** donde guardas cambios para no perderlos ni tener que hacer commit aÃºn.
Sirve cuando necesitas cambiar de rama o actualizarte, pero tienes trabajo en curso.

![Static Badge](https://img.shields.io/badge/git-stash-orange?logo=git)
![Static Badge](https://img.shields.io/badge/git-stash--list-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-stash--pop-green?logo=git)

---

### ğŸ“¦ `git stash` â€” Guardar cambios temporalmente

```bash
git stash
```

ğŸ“Œ **QuÃ© hace:**

- Guarda los cambios de tu directorio de trabajo y de staging en una â€œpilaâ€ (stack) de stashes.
- Deja tu directorio limpio (como si acabases de hacer `git checkout` sin cambios).

ğŸ’¡ Ãštil cuando:

- EstÃ¡s en una rama y necesitas cambiar a otra sin hacer commit.
- Vas a actualizar (`pull`) pero no quieres que tus cambios entren en conflicto todavÃ­a.

---

### ğŸ“œ `git stash list` â€” Ver la lista de stashes

```bash
git stash list
```

ğŸ“Œ **QuÃ© hace:**

- Muestra todas las entradas guardadas en tu â€œmochilaâ€ de stashes.
- Cada entrada tiene un Ã­ndice: `stash@{0}`, `stash@{1}`, etc.

Ejemplo de salida:

```
stash@{0}: WIP on feature-x: 9f3c2a1 agrega configuraciÃ³n inicial
stash@{1}: WIP on main: 7a5d6e4 corrige README
```

---

### ğŸ“¤ `git stash pop` â€” Recuperar cambios

```bash
git stash pop
```

ğŸ“Œ **QuÃ© hace:**

- Aplica el Ãºltimo stash guardado a tu directorio de trabajo.
- Borra ese stash de la lista.

ğŸ’¡ Si quieres aplicarlo pero **mantenerlo** en la lista:

```bash
git stash apply
```

---

### ğŸ—‘ï¸ `git stash drop` â€” Eliminar stashes

```bash
git stash drop stash@{0}
```

ğŸ“Œ **QuÃ© hace:**

- Borra la entrada especÃ­fica de la lista de stashes.

Para borrar todos:

```bash
git stash clear
```

---

### ğŸ§­ Flujo visual de Stash

```mermaid
flowchart LR
  A[Directorio con cambios] -->|git stash| B[Stash guardado]
  B -->|git stash list| C[Ver stashes]
  B -->|git stash pop| D[Recuperar cambios]
  B -->|git stash drop| E[Eliminar stash]
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Usa `git stash` solo para cambios temporales, no como sistema de commits.
- Nombra tus stashes para identificarlos mejor:

  ```bash
  git stash push -m "Trabajo parcial en login"
  ```

- Antes de aplicar un stash, asegÃºrate de estar en la rama correcta.

- Recuerda: `pop` aplica y borra, `apply` aplica y mantiene en la lista.

---

âœ… Con este tema podemos dominar el uso de **stash** para guardar y recuperar trabajo sin necesidad de commits.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## âœï¸ REWRITE HISTORY

En Git, reescribir el historial te permite **corregir, reorganizar o limpiar commits**.
Se usa para dejar un historial claro y profesional antes de subir o fusionar cambios.

âš ï¸ **Advertencia:** estos comandos modifican el historial, asÃ­ que Ãºsalos solo en ramas locales o en commits que aÃºn no se hayan hecho *push*.

![Static Badge](https://img.shields.io/badge/git-reset-red?logo=git)
![Static Badge](https://img.shields.io/badge/git-rebase-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-commit--amend-yellow?logo=git)

---

### ğŸ§­ `git reset` â€” Reubicar el puntero HEAD

`git reset` mueve el **HEAD** (la referencia del commit actual) hacia otro commit.
Sirve para deshacer commits o devolver archivos a un estado anterior.

```bash
git reset --soft <hash>
git reset --mixed <hash>
git reset --hard <hash>
```

ğŸ“Œ **Diferencias entre los modos:**

| Modo                  | QuÃ© afecta                       | QuÃ© conserva                      | Uso tÃ­pico                          |
| --------------------- | -------------------------------- | --------------------------------- | ----------------------------------- |
| `--soft`              | Mueve HEAD al commit indicado    | Mantiene los cambios en *staging* | Rehacer commit sin perder cambios   |
| `--mixed` *(default)* | Mueve HEAD y limpia el *staging* | Mantiene cambios en el directorio | Devolver cambios sin borrarlos      |
| `--hard`              | Mueve HEAD y elimina todo        | Nada (borra cambios) âš ï¸           | Reiniciar el repo a un punto exacto |

ğŸ’¡ **HEAD** es un puntero que indica en quÃ© commit estÃ¡s trabajando.

---

### ğŸ§© Ejemplo visual

```mermaid
flowchart LR
  A[Commit A] --> B[Commit B (HEAD actual)]
  B -->|git reset --soft A| C[HEAD vuelve a A (cambios guardados)]
  B -->|git reset --mixed A| D[HEAD vuelve a A (cambios visibles en directorio)]
  B -->|git reset --hard A| E[HEAD vuelve a A (todo eliminado âš ï¸)]
```

---

### ğŸª„ `git rebase` â€” Reaplicar commits sobre otra base

```bash
git rebase main
```

ğŸ“Œ **QuÃ© hace:**

- Toma los commits de tu rama actual y los â€œreaplicaâ€ sobre otra rama.
- Reescribe el historial para que tus cambios parezcan creados encima del Ãºltimo commit de la rama base.

ğŸ’¬ **Ejemplo prÃ¡ctico:**

```bash
git switch feature/login
git rebase main
```

ğŸ‘‰ Aplica los commits de `feature/login` sobre los mÃ¡s recientes de `main`.

ğŸ’¡ Ideal cuando tu rama se quedÃ³ atrÃ¡s y quieres **actualizarla sin crear un merge commit**.

---

### ğŸ§® Rebase interactivo

```bash
git rebase -i HEAD~3
```

ğŸ“Œ **QuÃ© hace:**

- Abre los Ãºltimos 3 commits en modo interactivo.
- Puedes **editar (edit)**, **combinar (squash)** o **eliminar (drop)** commits.

ğŸ’¬ Ejemplo de interfaz:

```
pick 8f3c2a1 agrega notas
squash 1a4b8f2 corrige typo
edit 7b9d3e3 mejora descripciÃ³n
```

ğŸ’¡ Usa este mÃ©todo para **limpiar tu historial antes de subirlo a GitHub**.

---

### ğŸ“ `git commit --amend` â€” Corregir el Ãºltimo commit

```bash
git commit --amend -m "Corrige error en mensaje anterior"
```

ğŸ“Œ **QuÃ© hace:**

- Modifica el Ãºltimo commit (mensaje o contenido).
- Ãštil para pequeÃ±os errores justo antes de hacer *push*.

âš ï¸ **PrecauciÃ³n:** si ya hiciste *push*, evita usarlo (cambiarÃ­a el historial remoto).

---

### ğŸ§  Buenas prÃ¡cticas

- Usa `rebase` para mantener un historial lineal y limpio.
- Usa `reset --soft` cuando necesites rehacer un commit sin perder trabajo.
- Evita `reset --hard` si no estÃ¡s completamente seguro.
- Antes de reescribir commits, verifica con:

  ```bash
  git log --oneline --graph
  ```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ” INSPECT & COMPARE

Estos comandos sirven para **examinar el historial** y **comparar cambios** entre commits, archivos y ramas. Son tus â€œlupasâ€ para entender quÃ© pasÃ³ en tu repo en cada momento.

![Static Badge](https://img.shields.io/badge/git-log-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-diff-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-show-orange?logo=git)

---

### ğŸ“ `git log` â€” Ver historial de commits

```bash
git log
```

ğŸ“Œ **QuÃ© hace:**

- Muestra la lista de commits de la rama actual en orden inverso (el mÃ¡s reciente primero).
- Incluye hash del commit, autor, fecha y mensaje.

ğŸ§© **Variantes Ãºtiles:**

| Comando                    | Resultado                                                      |
| -------------------------- | -------------------------------------------------------------- |
| `git log --oneline`        | Vista compacta, un commit por lÃ­nea.                           |
| `git log --graph`          | Vista grÃ¡fica de ramas y merges.                               |
| `git log --decorate`       | Muestra nombres de ramas y tags junto al commit.               |
| `git log --follow archivo` | Historial completo de un archivo, incluso si cambiÃ³ de nombre. |

ğŸ’¡ **CombÃ­nalos:**

```bash
git log --oneline --graph --decorate --all
```

ğŸ‘‰ Vista corta, con ramas, tags y todo el historial.

---

### ğŸ§© `git diff` â€” Comparar diferencias

Compara el contenido de archivos en distintos estados.

| Comando                    | QuÃ© compara                                            |
| -------------------------- | ------------------------------------------------------ |
| `git diff`                 | Cambios en tu directorio de trabajo **no preparados**. |
| `git diff --staged`        | Cambios en el *staging area* frente al Ãºltimo commit.  |
| `git diff ramaA..ramaB`    | Diferencias entre dos ramas.                           |
| `git diff <hash1> <hash2>` | Diferencias entre dos commits.                         |

ğŸ’¬ **Ejemplo prÃ¡ctico:**

```bash
git diff main..feature/login
```

ğŸ‘‰ Muestra los cambios entre `main` y la rama `feature/login`.

---

### ğŸ‘ï¸ `git show` â€” Ver detalles de un commit

```bash
git show <hash-commit>
```

ğŸ“Œ **QuÃ© hace:**

- Muestra un commit especÃ­fico con autor, fecha, mensaje y cambios aplicados.
- Ãštil para revisar **quÃ© exactamente se cambiÃ³** en un commit puntual.

ğŸ’¡ TambiÃ©n puedes usarlo para tags o ramas:

```bash
git show v1.0.0
```

ğŸ‘‰ Muestra la informaciÃ³n del commit donde estÃ¡ ese tag.

---

### ğŸ§­ Flujo visual

```mermaid
flowchart LR
  A[Historial de commits] -->|git log| B[Vista detallada]
  B -->|git diff| C[Comparar cambios]
  C -->|git show| D[Inspeccionar un commit especÃ­fico]
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Usa `git log --oneline --graph` antes de reescribir o resetear para entender el Ã¡rbol.
- Combina `git diff` con `--staged` antes de hacer commit para revisar exactamente quÃ© vas a guardar.
- Usa `git show <hash>` cuando necesites confirmar detalles de un commit pasado.
- Si quieres exportar diferencias, puedes hacer:

  ```bash
  git diff > cambios.patch
  ```
  
---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸš« IGNORING PATTERNS

Sirve para **indicar a Git quÃ© archivos o carpetas NO debe rastrear ni subir al repositorio**. Esto mantiene tu repo limpio y evita subir archivos temporales, secretos o dependencias pesadas.

![Static Badge](https://img.shields.io/badge/.gitignore-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-config--excludesfile-blue?logo=git)

---

### ğŸ“œ `.gitignore` â€” Ignorar archivos en un repositorio

Crea un archivo llamado `.gitignore` en la raÃ­z de tu proyecto con los patrones que quieras ignorar.

Ejemplo bÃ¡sico:

```gitignore
# Ignorar carpetas de logs
logs/

# Ignorar todos los archivos .notes
*.notes

# Ignorar cualquier carpeta con este patrÃ³n
pattern*/
```

ğŸ“Œ **QuÃ© hace:**

- Todo lo listado ahÃ­ **no serÃ¡ rastreado ni agregado al staging**.
- Puedes poner comentarios con `#`.
- Puedes usar comodines `*` y `?` para patrones.

ğŸ’¡ **Tips:**

- AÃ±ade primero `.gitignore` antes de subir tu proyecto.
- Puedes crear varios `.gitignore` en subcarpetas (Git aplica el patrÃ³n de manera jerÃ¡rquica).
- GitHub tiene plantillas para `.gitignore` comunes: [github.com/github/gitignore](https://github.com/github/gitignore)

---

### ğŸŒ Ignorar archivos de manera global

Puedes definir un archivo de exclusiÃ³n global para todos tus repos:

```bash
git config --global core.excludesfile ~/.gitignore_global
```

Luego crea el archivo `~/.gitignore_global` y aÃ±ade ahÃ­ patrones comunes para todos tus proyectos.

ğŸ’¬ **Ejemplo:**

```bash
# ~/.gitignore_global
.DS_Store
node_modules/
*.log
```

---

### ğŸ§­ Flujo visual

```mermaid
flowchart LR
  A[Archivos en directorio] -->|git add| B[Staging area]
  A -.archivos en .gitignore.-X B
  B -->|git commit| C[Repositorio Git]
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Siempre crea tu `.gitignore` al inicio del proyecto.
- No subas archivos sensibles (contraseÃ±as, llaves) nunca.
- Usa plantillas de `.gitignore` especÃ­ficas para tu lenguaje o framework.
- Para quitar de Git un archivo que ya subiste pero ahora quieres ignorar:

  ```bash
  git rm --cached archivo_secreto.txt
  ```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸŒ¿ Branches (atajos prÃ¡cticos y pro tips)

![Static Badge](https://img.shields.io/badge/git-branch-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-switch-teal?logo=git)
![Static Badge](https://img.shields.io/badge/git-merge-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-push--u-blue?logo=git)

### ğŸ“‹ Listado y navegaciÃ³n

```bash
git branch           # Lista ramas locales ( * = actual )
git branch -r        # Ramas remotas
git branch -a        # Todas (locales + remotas)
git switch main      # Cambiar de rama (moderno)
git checkout main    # Cambiar de rama (clÃ¡sico)
```

### ğŸŒ± Crear y entrar (formas equivalentes)

```bash
git switch -c feature/x          # crea y entra (-c = create)
git checkout -b feature/x        # clÃ¡sico
git branch feature/x && git switch feature/x  # crear y luego entrar
```

### âœï¸ Renombrar rama

```bash
git branch -m nuevo-nombre       # renombra la rama actual (-m = move/rename)
```

> Si ya existÃ­a en remoto con el nombre viejo:

```bash
git push origin -u nuevo-nombre          # sube la nueva
git push origin --delete nombre-viejo    # elimina la remota vieja
git branch --unset-upstream              # (si hace falta) limpia upstream
git branch --set-upstream-to=origin/nuevo-nombre
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ”— Tracking (conectar tu rama local con la remota)

### Primera vez que empujas una rama nueva

```bash
git push -u origin feature/x   # -u = set-upstream (queda vinculada)
# Luego ya basta con:
git push
git pull
```

### Ver / cambiar upstream

```bash
git branch -vv                          # muestra tracking de cada rama
git branch --set-upstream-to=origin/feature/x
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ”„ Ramas remotas y limpieza

### Obtener ramas nuevas/borradas del remoto

```bash
git fetch --prune            # sincroniza y limpia referencias obsoletas
# o
git remote prune origin
```

### Borrar ramas (local y remoto)

```bash
git branch -d feature/x      # borra local (si ya fue mergeada)
git branch -D feature/x      # borra local forzado âš ï¸
git push origin --delete feature/x   # borra la rama en GitHub
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ¤ Merge (estrategias Ãºtiles)

### Merge normal (fast-forward si aplica)

```bash
git switch main
git merge feature/x
```

### Forzar commit de merge aunque sea FF

```bash
git merge --no-ff feature/x
# Ãštil para dejar el â€œhitoâ€ del merge visible en el historial.
```

- Una fusiÃ³n FF ocurre cuando la rama en la que estÃ¡s haciendo el merge no ha tenido nuevos commits desde que se creÃ³ o actualizÃ³ la rama que quieres fusionar.
- En este caso, Git simplemente avanza el puntero de la rama actual al Ãºltimo commit de la rama que se estÃ¡ integrando, sin crear un nuevo "merge commit".

### Traerte los cambios pero sin crear commit de merge

```bash
git merge --squash feature/x
git commit -m "Squash: integra feature/x en un solo commit"
# Ideal para mantener historial mÃ¡s limpio cuando hubo muchos commits intermedios.
```

### Si hay conflicto

```bash
# Editas archivos en conflicto (VSCode ayuda mucho)
git add <archivos_resueltos>
git commit                      # completa el merge

# Si necesitas abortar:
git merge --abort
```

---

### ğŸª„ Rebase rÃ¡pido para mantener la rama al dÃ­a (lineal)

```bash
git switch feature/x
git fetch origin
git rebase origin/main     # re-aplica tus commits encima de main actualizado
# Si hay conflictos: resuÃ©lvelos, `git add` y:
git rebase --continue
# Para abortar:
git rebase --abort
```

> Tip: Usa **rebase** en ramas de trabajo antes del PR para un historial lineal y fÃ¡cil de revisar. Evita rebase en ramas compartidas/pÃºblicas ya empujadas si otras personas dependen de ese historial.

---

### ğŸ’ Cherry-pick (traer un commit especÃ­fico)

```bash
git cherry-pick <hash>
# Copia el commit indicado a tu rama actual (Ãºtil para hotfixes puntuales).
```

---

### ğŸ›¡ï¸ Buenas prÃ¡cticas rÃ¡pidas

- Crea siempre ramas por feature: `feature/â€¦`, `hotfix/â€¦`, `release/â€¦`.
- **`push -u`** la primera vez: te ahorra teclear remoto/rama luego.
- **`--no-ff`** para dejar un â€œhitoâ€ de merge visible; **`--squash`** para compactar ruido.
- **`fetch --prune`** de vez en cuando para limpiar ramas remotas obsoletas.
- Antes del PR: `git fetch`, `git rebase origin/main`, resuelve y empuja (historial limpio).
- Protege `main` en GitHub (branch protection) para exigir PRs y revisiones.

---

### ğŸ“¦ Mini-recap aplicado a tu flujo (decktSsail â†’ Ssail-1)

1. En **decktSsail**:

   ```bash
   git switch -c feature/git-notes-update
   # â€¦editaâ€¦
   git add .
   git commit -m "Actualiza notas de Git: branches avanzados"
   git push -u origin feature/git-notes-update
   ```

2. Abres el **PR** hacia `Ssail-1/PlatziNotes`.
3. En **Ssail-1**: revisas y **Merge** (puedes elegir *Create a merge commit*, *Squash & merge* o *Rebase & merge*).
4. (Opcional) Borra la rama:

   ```bash
   git branch -d feature/git-notes-update
   git push origin --delete feature/git-notes-update
   ```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## Lectura de AclaraciÃ³n


### ğŸŸ¢ **Parte 1: Upstream, unset-upstream y prune**

#### ğŸ“ Â¿QuÃ© es â€œupstreamâ€?

Cuando haces `git push -u origin rama-x`, estÃ¡s diciendo:

> â€œMi rama local `rama-x` estÃ¡ vinculada (tracking) con la rama remota `origin/rama-x`â€.

Eso se llama **upstream branch**: la rama remota que tu rama local sigue.
Luego, con solo `git push` o `git pull`, Git ya sabe a quÃ© remoto y rama subir/bajar.

---

#### ğŸ“ `git branch --unset-upstream`

Sirve para **desvincular** tu rama local de cualquier rama remota.
Ãštil si:

- Cambiaste el nombre de la rama en remoto.
- Borraste la rama remota.
- Quieres que tu rama local deje de empujar automÃ¡ticamente.

Es como decir â€œolvida esa conexiÃ³nâ€.

---

#### ğŸ“ `git branch --set-upstream-to=origin/nueva-rama`

Sirve para **vincular manualmente** tu rama local a una rama remota (o cambiarla).
Ejemplo:

```bash
git branch --set-upstream-to=origin/dev
```

Ahora tu rama local â€œsabeâ€ que tiene que hacer `pull/push` a `origin/dev`.

---

#### ğŸ“ `git fetch --prune` / `git remote prune origin`

Cuando borras ramas en GitHub, tu Git local sigue guardando referencias â€œfantasmaâ€ de esas ramas remotas (aparecen con `git branch -r`).
`--prune` limpia esas referencias obsoletas.
Es como barrer â€œcachÃ©â€ para que tu lista de ramas remotas estÃ© al dÃ­a.

---

ğŸ’¡ **AnalogÃ­a:**

- **set-upstream** = â€œenlazarâ€ el cable entre dos equipos.
- **unset-upstream** = â€œdesconectarâ€ el cable.
- **fetch --prune** = â€œquitar los cables viejos que ya no existenâ€.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

### ğŸŸ¢ **Parte 2: Merge, fast-forward, squash y no-ff**

#### ğŸ“ Fast-forward merge

Sucede cuando tu rama de destino (ej. `main`) no tiene commits nuevos desde que creaste tu rama de feature.
Git no necesita hacer un commit de merge, simplemente mueve el puntero HEAD para adelante.

Visualmente:

```
main: A --- B
feature: A --- B --- C --- D
```

Cuando haces merge, **fast-forward**:

```
main: A --- B --- C --- D (puntero avanza)
```

No se crea commit de merge, queda lineal.

---

#### ğŸ“ Merge normal (con commit de merge)

Sucede cuando **las dos ramas tienen commits distintos**.
Git necesita crear un commit de merge para unir los dos historiales.

---

#### ğŸ“ `--no-ff` (no fast-forward)

Sirve para **forzar la creaciÃ³n de un commit de merge** incluso si podrÃ­a ser fast-forward.
Â¿Por quÃ©?
Porque deja un **hito** (punto visible) en el historial de que esa rama fue fusionada.
Esto es Ãºtil para equipos: se ve claramente cuÃ¡ndo se integrÃ³ una feature.

---

#### ğŸ“ `git merge --squash` + `git commit -m`

Son dos pasos:

1. `git merge --squash feature/x` â†’ junta todos los commits de `feature/x` en staging como un solo paquete.
2. `git commit -m "Squash: integra feature/x en un solo commit"` â†’ haces un commit Ãºnico.

Resultado:

- La rama `feature/x` no queda en el historial de `main` con sus mÃºltiples commits, solo un commit â€œgrandeâ€.
- Se mantiene el historial limpio.

---

ğŸ’¡ **AnalogÃ­a:**

- Fast-forward = solo avanzar el marcador.
- Merge normal = pegar dos caminos distintos.
- No-ff = pegar dos caminos y dejar â€œposteâ€ que marque que se unieron.
- Squash = juntar todos los ladrillos en uno solo antes de pegarlos.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

### ğŸŸ¢ **Parte 3: Rebase (quÃ© es y cuÃ¡ndo usarlo)**

#### ğŸ“ QuÃ© es rebase

â€œRebaseâ€ toma tus commits y los **reaplica sobre otra base** (otro commit mÃ¡s nuevo).
Sirve para **actualizar tu rama** con los Ãºltimos cambios de `main` sin crear un commit de merge.

Visualmente:

```
main: A --- B --- C
feature: A --- D --- E
```

Haces:

```bash
git switch feature
git rebase main
```

Resultado:

```
main: A --- B --- C
feature: A --- B --- C --- D --- E (reaplicado)
```

No hay commit de merge, queda lineal.

---

#### ğŸ“ CuÃ¡ndo usarlo

- Cuando tu rama se quedÃ³ atrÃ¡s de `main` y quieres traer los cambios **antes** de abrir un PR.
- Para mantener un historial limpio y lineal.
- No usar en ramas compartidas ya empujadas (porque cambia hashes).

---

#### ğŸ“ `git rebase --continue`

Se usa **despuÃ©s de resolver conflictos** durante un rebase.
El flujo es:

```bash
git rebase main
# Conflicto
# editas archivos
git add archivos_resueltos
git rebase --continue
```

Si quieres abortar:

```bash
git rebase --abort
```

---

ğŸ’¡ **AnalogÃ­a:**
Merge es como pegar dos caminos con un puente.
Rebase es como levantar tu camino y volverlo a colocar justo al final del camino principal.

---

</**Fin de Lectura de Aclaracion**>

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸŒ³ Advanced Branching

![Static Badge](https://img.shields.io/badge/git-upstream-purple?logo=git)
![Static Badge](https://img.shields.io/badge/git-prune-grey?logo=git)
![Static Badge](https://img.shields.io/badge/git-merge--no--ff-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-squash-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-rebase-blue?logo=git)

### ğŸ“ Upstream y seguimiento

```bash
git push -u origin feature/x                # establece upstream
git branch --set-upstream-to=origin/dev     # cambia upstream manualmente
git branch --unset-upstream                 # elimina upstream
```

ğŸ’¡ Vincula/desvincula ramas locales con remotas para usar `push` y `pull` sin parÃ¡metros.

---

### ğŸ“ Limpiar referencias obsoletas

```bash
git fetch --prune
git remote prune origin
```

ğŸ’¡ Limpia ramas remotas eliminadas para que no aparezcan en `git branch -r`.

---

### ğŸ“ Merge avanzado

```bash
git merge --no-ff feature/x
```

ğŸ’¡ Forza commit de merge (deja â€œhitoâ€ visible).

```bash
git merge --squash feature/x
git commit -m "Squash: integra feature/x en un solo commit"
```

ğŸ’¡ Junta todos los commits de `feature/x` en uno solo para mantener limpio el historial.

---

### ğŸ“ Rebase para actualizar ramas

```bash
git switch feature/x
git fetch origin
git rebase origin/main
```

ğŸ’¡ Reaplica tus commits sobre `main` actualizado (historial lineal).

Durante conflictos:

```bash
git add archivos_resueltos
git rebase --continue   # despuÃ©s de resolver
git rebase --abort      # para cancelar
```

---

### ğŸ’¡ Buenas prÃ¡cticas

- Protege `main` en GitHub y haz merges mediante PRs.
- Usa `--no-ff` cuando quieras dejar constancia de una feature mergeada.
- Usa `--squash` para limpiar commits irrelevantes.
- Usa `rebase` antes de abrir PRs para actualizar tu rama sin merges ruidosos.
- Haz `fetch --prune` regularmente para mantener tus ramas limpias.

---

âœ… Hasta aqui ya tenemos **el kit avanzado de ramas**.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ§  Mapa mental â€” Advanced Branching Flow

Este mapa muestra cÃ³mo se relacionan los conceptos mÃ¡s importantes:

- **Upstream y fetch/prune** (sincronizaciÃ³n con remotos)
- **Merge, no-ff, squash** (cÃ³mo se integran ramas)
- **Rebase** (actualizaciÃ³n limpia de ramas antes del merge)

---

```mermaid
mindmap
  root((Advanced Branching))
    Upstream & Remote
      "git push -u origin <branch>"
      "git branch --set-upstream-to=origin/<branch>"
      "git fetch --prune"
      "git remote prune origin"
    Merge Strategies
      Fast-forward
        "Simplemente avanza el puntero HEAD"
      "--no-ff"
        "Crea commit de merge (marca el hito)"
      "--squash"
        "Combina todos los commits en uno solo"
    Rebase
      "git rebase origin/main"
      "Reaplica commits sobre una nueva base"
      "Mantiene historial lineal y limpio"
      Conflicts
        "git add archivos_resueltos"
        "git rebase --continue"
        "git rebase --abort"
    Best Practices
      "Rebase antes de un PR"
      "Protege main en GitHub"
      "Usa fetch --prune regularmente"
      "Usa no-ff para dejar registro del merge"
      "Usa squash para mantener historial limpio"
```

---

### ğŸ’¡ CÃ³mo leerlo

- Cada rama del mapa representa una parte del flujo avanzado que ya dominaste.
- Puedes visualizarlo directamente en VSCode si tienes activa la extensiÃ³n *Markdown Preview Mermaid Support*.
- Si no se renderiza, no pasa nada: GitHub tambiÃ©n lo mostrarÃ¡ correctamente en su vista previa.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸŒ Advanced Remotes â€” Forks, Upstream & Synchronization

![Static Badge](https://img.shields.io/badge/git-remote-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-fetch--upstream-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-rebase--upstream-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-push--origin-purple?logo=git)

---

### ğŸ§© Â¿QuÃ© es un *remote*?

Un **remote** es una referencia a un repositorio alojado en otro lugar (GitHub, GitLab, etc.).
Normalmente tu repo tiene:

* `origin` â†’ apunta al repositorio principal (tu fork o el que creaste).
* `upstream` â†’ apunta al repositorio original del que hiciste fork (por ejemplo, `Ssail-1/PlatziNotes` cuando trabajas desde `decktSsail`).

---

### ğŸ”— Conectar el repo original (upstream)

Desde tu fork clonado (ejemplo, en la cuenta **decktSsail**):

```bash
git remote add upstream git@github.com:Ssail-1/PlatziNotes.git
```

ğŸ“Œ **QuÃ© hace:**

* Agrega el repo original con el nombre `upstream`.
* No afecta tu `origin`, simplemente te permite traer actualizaciones del repo fuente.

ğŸ’¡ **Verifica tus remotos:**

```bash
git remote -v
```

DeberÃ­as ver algo como:

```
origin   git@github.com-decktSsail:decktSsail/PlatziNotes.git (fetch)
origin   git@github.com-decktSsail:decktSsail/PlatziNotes.git (push)
upstream git@github.com-Ssail:Ssail-1/PlatziNotes.git (fetch)
upstream git@github.com-Ssail:Ssail-1/PlatziNotes.git (push)
```

---

### ğŸ”„ Actualizar tu fork con los cambios del original

A veces el repo original (`upstream`) cambia y tÃº quieres mantener tu fork actualizado.

1. **Traer cambios del original:**

   ```bash
   git fetch upstream
   ```

2. **Fusionar esos cambios en tu rama local principal:**

   ```bash
   git switch main
   git merge upstream/main
   ```

ğŸ’¡ **O hacerlo con rebase (mÃ¡s limpio):**

```bash
git rebase upstream/main
```

ğŸ‘‰ Esto coloca tus commits encima de los mÃ¡s recientes del original.

---

### ğŸ“¤ Subir los cambios actualizados a tu fork

Una vez sincronizado tu `main` local:

```bash
git push origin main
```

AsÃ­ tu fork en GitHub queda actualizado con el original.

---

### ğŸ§  Â¿CuÃ¡ndo usar *merge* vs *rebase* en forks?

| AcciÃ³n                     | CuÃ¡ndo usar                                        | Resultado                    |
| -------------------------- | -------------------------------------------------- | ---------------------------- |
| `git merge upstream/main`  | Cuando no te importa dejar un commit de merge.     | Mantiene historia completa.  |
| `git rebase upstream/main` | Cuando quieres mantener historial lineal y limpio. | Tus commits quedan al final. |

ğŸ’¬ En proyectos colaborativos grandes, lo normal es usar `rebase` antes de un Pull Request.

---

### ğŸ§¹ Limpiar ramas remotas obsoletas

```bash
git fetch --prune upstream
git fetch --prune origin
```

ğŸ’¡ Elimina referencias de ramas que ya fueron borradas en los repos remotos.

---

### ğŸ§­ Flujo visual

```mermaid
flowchart TD
  A[Repositorio Original (Ssail-1)] -->|fork| B[Fork (decktSsail)]
  B -->|clone| C[Local VM]
  A -->|fetch upstream| C
  C -->|merge/rebase upstream/main| B
  B -->|push origin main| D[GitHub Fork Actualizado]
```

---

### ğŸ’¡ Buenas prÃ¡cticas

* Usa nombres claros: `origin` (tu fork) y `upstream` (original).
* Haz `fetch upstream` periÃ³dicamente para mantener tu fork al dÃ­a.
* Rebase antes de enviar PRs para evitar conflictos.
* Nunca hagas push al `upstream` (solo lees de Ã©l).
* Verifica tus remotos con `git remote -v` antes de ejecutar un push.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ› ï¸ RestauraciÃ³n segura de commits

![Static Badge](https://img.shields.io/badge/git-revert-red?logo=git)
![Static Badge](https://img.shields.io/badge/git-checkout-yellow?logo=git)

---

### ğŸ”™ `git revert <hash>`

Revierte un commit creando **un nuevo commit inverso** (sin alterar el historial).

```bash
git revert 7f3c2a1
```

ğŸ’¡ Perfecto para revertir errores en repos pÃºblicos o remotos, ya que no borra historia.

---

### ğŸ•“ `git checkout <hash>`

Permite moverte a un commit pasado temporalmente (modo *detached HEAD*).

```bash
git checkout 7f3c2a1
```

Para volver a la rama anterior:

```bash
git switch -
```

ğŸ’¡ Ideal para revisar estados pasados sin modificar el historial actual.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ“˜ TAGS & RELEASES

Las **etiquetas** (*tags*) se usan para marcar puntos especÃ­ficos del historial del repositorio, generalmente para **versionar** o seÃ±alar commits importantes como versiones estables o entregas finales.
En GitHub, estas etiquetas se pueden usar para crear **releases**, con notas de versiÃ³n o archivos de publicaciÃ³n.

![Static Badge](https://img.shields.io/badge/git-tag-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-push--tags-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-show--ref--tags-yellow?logo=git)

---

### ğŸ·ï¸ Concepto y tipos de tags

---

#### ğŸ”¹ Â¿QuÃ© es un tag?

Un **tag** es una referencia inmutable a un commit especÃ­fico.
Sirve como marcador o â€œfotoâ€ dentro del historial de Git.
Ideal para marcar **versiones estables** o **puntos clave del proyecto**.

ğŸ’¡ *Ejemplo:*

> Al terminar una funcionalidad completa y estable, puedes crear un tag `v1.0` para marcar esa versiÃ³n.

---

#### ğŸ”¹ Tipos de etiquetas

| Tipo                     | DescripciÃ³n                                                                | Ejemplo                                        |
| ------------------------ | -------------------------------------------------------------------------- | ---------------------------------------------- |
| **Ligera (lightweight)** | Solo apunta al hash del commit, sin informaciÃ³n extra.                     | `git tag v1.0`                                 |
| **Anotada (annotated)**  | Contiene metadatos (autor, fecha, mensaje). Ideal para versiones pÃºblicas. | `git tag -a v1.0 -m "VersiÃ³n estable inicial"` |

ğŸ“Œ **RecomendaciÃ³n:**
Siempre usa tags anotados (`-a`) para versiones oficiales o pÃºblicas.

---

#### ğŸ”¹ Asignar etiquetas a commits especÃ­ficos

```bash
git tag -a v1.0.1 <hash-commit> -m "Hotfix versiÃ³n 1.0.1"
```

ğŸ’¬ Esto marca un commit anterior con una etiqueta, aunque no sea el mÃ¡s reciente.

---

#### ğŸ”¹ Ver etiquetas existentes

```bash
git tag
```

ğŸ“‹ Lista todas las etiquetas locales.

---

#### ğŸ”¹ Mostrar informaciÃ³n detallada del tag

```bash
git show v1.0
```

ğŸ“Œ Muestra el commit asociado, el mensaje del tag, autor, fecha y contenido del cambio.

---

#### ğŸ”¹ Ver asociaciones entre tags y commits

```bash
git show-ref --tags
```

ğŸ“Œ Lista cada tag junto al hash del commit correspondiente.
Perfecto para ubicar de forma rÃ¡pida quÃ© commit estÃ¡ marcado por cada etiqueta.

---

### ğŸŒ GestiÃ³n remota y manipulaciÃ³n de tags

---

#### ğŸ“¤ Subir tags al repositorio remoto

```bash
git push origin --tags
```

ğŸ“Œ Sube **todos los tags** locales al remoto.

O, si quieres subir uno especÃ­fico:

```bash
git push origin v1.0
```

---

#### ğŸ—‘ï¸ Eliminar etiquetas

##### Localmente:

```bash
git tag -d v1.0
```

##### En remoto:

Primero elimina el tag local y luego el remoto:

```bash
git push origin --delete v1.0
```

O alternativamente:

```bash
git push origin :refs/tags/v1.0
```

ğŸ’¡ Si el tag ya fue subido, recuerda borrarlo en ambos lugares para mantener sincronÃ­a.

---

#### ğŸ” Reasignar un tag

Si etiquetaste el commit incorrecto:

```bash
git tag -d v1.0
git tag -a v1.0 <hash-correcto> -m "Etiqueta corregida"
git push origin -f v1.0
```

âš ï¸ `-f` (force) es necesario si el tag ya existÃ­a en el remoto.
Ãšsalo con cuidado para no sobrescribir versiones ya distribuidas.

---

### ğŸš€ Releases en GitHub y Buenas prÃ¡cticas

---

#### ğŸ“¦ Crear un Release en GitHub

1. Ve a la pestaÃ±a **Releases** en tu repositorio.
2. Haz clic en **â€œDraft a new releaseâ€**.
3. Elige un tag existente o crea uno nuevo.
4. Agrega tÃ­tulo, descripciÃ³n y notas de cambios (Changelog).
5. Publica el Release.

ğŸ’¡ Los Releases pueden incluir binarios, ejecutables o documentaciÃ³n especÃ­fica de esa versiÃ³n.

---

#### ğŸ§  Flujo visual â€” Tags & Releases

```mermaid
flowchart LR
  A[Commit estable] -->|git tag -a v1.0| B[Tag local]
  B -->|git push origin --tags| C[Tag remoto]
  C -->|GitHub Release| D[VersiÃ³n pÃºblica documentada]
  D -->|Usuarios descargan| E[VersiÃ³n v1.0 estable]
```

---

#### ğŸ’¡ Buenas prÃ¡cticas

âœ… Usa **versionado semÃ¡ntico (SemVer)**:
`vMAJOR.MINOR.PATCH`
Ejemplo:

* `v1.0.0` â†’ primera versiÃ³n estable.
* `v1.1.0` â†’ nueva funcionalidad sin romper compatibilidad.
* `v1.1.1` â†’ correcciÃ³n menor o hotfix.

âœ… Crea tags **anotados** (`-a`) para mantener informaciÃ³n completa.
âœ… Revisa que tu `main` estÃ© estable antes de etiquetar.
âœ… AÃ±ade un archivo **CHANGELOG.md** con los cambios importantes de cada versiÃ³n.
âœ… No borres tags antiguos, son parte del historial del proyecto.
âœ… Usa tags tambiÃ©n para **documentaciÃ³n**, **entregas de prÃ¡cticas** o **checkpoints** en proyectos acadÃ©micos.

---

âœ… Con esto ya dominas el uso **profesional de etiquetas y releases**, desde la creaciÃ³n local hasta su publicaciÃ³n en GitHub.

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ§¹ MAINTENANCE & OPTIMIZATION

Git guarda todo: commits, objetos, ramas, referenciasâ€¦ con el tiempo esto puede generar **archivos innecesarios** o referencias obsoletas.
Estos comandos te ayudan a **mantener tu repositorio limpio, liviano y funcional.**

![Static Badge](https://img.shields.io/badge/git-gc-blue?logo=git)
![Static Badge](https://img.shields.io/badge/git-fsck-green?logo=git)
![Static Badge](https://img.shields.io/badge/git-reflog-yellow?logo=git)
![Static Badge](https://img.shields.io/badge/git-clean-red?logo=git)

---

### ğŸ§° `git gc` â€” Garbage Collector (compacta y optimiza)

```bash
git gc
```

ğŸ“Œ **QuÃ© hace:**

* â€œEmpacaâ€ objetos sueltos (commits, blobs, etc.) en archivos mÃ¡s compactos.
* Borra datos temporales que ya no se usan.
* Reduce el tamaÃ±o del repositorio y mejora el rendimiento.

ğŸ’¡ Git ejecuta este proceso automÃ¡ticamente de vez en cuando, pero puedes forzarlo manualmente.

âš™ï¸ **Modo agresivo (mÃ¡s profundo):**

```bash
git gc --aggressive --prune=now
```

ğŸ‘‰ Reorganiza toda la base de datos interna de Git y elimina todo lo que ya no se referencia.
âš ï¸ Puede tardar varios minutos en repos grandes.

---

### ğŸ©º `git fsck` â€” VerificaciÃ³n de integridad

```bash
git fsck
```

ğŸ“Œ **QuÃ© hace:**

* Verifica la integridad de tu repositorio.
* Detecta objetos daÃ±ados o referencias perdidas.

ğŸ’¡ Ãšsalo si sospechas de corrupciÃ³n de datos o errores en `.git/`.

ğŸ” **Ver objetos huÃ©rfanos (dangling commits):**

```bash
git fsck --lost-found
```

ğŸ‘‰ Muestra commits o blobs sin referencia a ninguna rama, Ãºtiles para recuperar trabajo perdido.

---

### ğŸ§­ `git reflog` â€” Historial de movimientos (el salvavidas)

```bash
git reflog
```

ğŸ“Œ **QuÃ© hace:**

* Muestra todos los movimientos de HEAD: cambios de rama, resets, merges, rebases, etc.
* Te permite **recuperar commits eliminados** incluso despuÃ©s de un `reset --hard`.

ğŸ’¬ **Ejemplo de uso:**

```bash
git reflog
# muestrarÃ¡ algo como:
# a7c9b1d HEAD@{0}: reset: moving to HEAD~1
# 1f2d9e0 HEAD@{1}: commit: agrega archivo de configuraciÃ³n
```

ğŸ‘‰ Puedes restaurar un commit perdido asÃ­:

```bash
git checkout <hash-commit-perdido>
# o crear una rama para recuperarlo:
git switch -c recuperacion <hash-commit-perdido>
```

ğŸ’¡ Es uno de los comandos mÃ¡s Ãºtiles para â€œdeshacer el desastreâ€.

---

### ğŸ§¼ `git clean` â€” Limpieza de archivos no rastreados

```bash
git clean -n
```

ğŸ“Œ Muestra quÃ© archivos **no rastreados (untracked)** serÃ­an eliminados.
No borra nada todavÃ­a.

```bash
git clean -f
```

ğŸ“Œ Elimina los archivos no rastreados (sin commit, sin staging).

ğŸ’¡ **ParÃ¡metros Ãºtiles:**

| Flag | AcciÃ³n                                                    |
| ---- | --------------------------------------------------------- |
| `-f` | Forzar eliminaciÃ³n.                                       |
| `-d` | Incluir directorios no rastreados.                        |
| `-x` | Borra tambiÃ©n los archivos ignorados por `.gitignore`. âš ï¸ |
| `-i` | Modo interactivo (elige quÃ© borrar).                      |

ğŸ” **Ejemplo completo:**

```bash
git clean -fd
```

ğŸ‘‰ Elimina todo lo no rastreado: carpetas y archivos, dejando tu repo como nuevo.

---

### ğŸ§© Flujo visual de mantenimiento

```mermaid
flowchart TD
    A[Repositorio con objetos viejos] -->|git gc| B[Compactado y optimizado]
    A -->|git fsck| C[Verifica integridad]
    A -->|git reflog| D[Recupera commits perdidos]
    A -->|git clean| E[Elimina archivos no rastreados]
```

---

### ğŸ’¡ Buenas prÃ¡cticas de mantenimiento

âœ… Ejecuta `git gc` al menos una vez por mes en proyectos grandes.
âœ… Usa `git fsck` despuÃ©s de fallos de energÃ­a o errores en Git.
âœ… Haz `git reflog` si perdiste commits por accidente.
âœ… Ejecuta `git clean -n` antes de borrar, para ver quÃ© eliminarÃ¡s.
âœ… No ejecutes `--aggressive` muy seguido, solo en repos con mucho historial.

---

âœ… Con esto dominas el mantenimiento completo de un repositorio:
cÃ³mo mantenerlo rÃ¡pido, Ã­ntegro y limpio, **sin perder nada importante.**

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

## ğŸ’« FINAL BLOCK â€” Cierre del MÃ³dulo Git: Buenas prÃ¡cticas y preparaciÃ³n profesional

![Static Badge](https://img.shields.io/badge/git-professional-blue?logo=git)
![Static Badge](https://img.shields.io/badge/documentation-green?logo=markdown)
![Static Badge](https://img.shields.io/badge/portfolio-orange?logo=github)

---

### ğŸ¯ Objetivo de este cierre

Consolidar todo lo aprendido sobre Git y dejar tu entorno listo para la siguiente fase:
**colaborar, compartir y presentar proyectos profesionales** en GitHub.

---

### ğŸ§­ 1. Estructura profesional de repositorios

ğŸ’¡ **Buenas prÃ¡cticas de organizaciÃ³n**

| Elemento          | DescripciÃ³n                                                            | Ejemplo                               |
| ----------------- | ---------------------------------------------------------------------- | ------------------------------------- |
| `README.md`       | Portada del proyecto. Explica quÃ© hace, cÃ³mo usarlo y cÃ³mo contribuir. | Breve, con secciones claras y badges. |
| `.gitignore`      | Evita subir archivos innecesarios.                                     | Logs, dependencias, claves privadas.  |
| `LICENSE`         | Define permisos de uso.                                                | MIT, GPL, CC, etc.                    |
| `CHANGELOG.md`    | Historial de cambios por versiÃ³n.                                      | Usar formato SemVer.                  |
| `CONTRIBUTING.md` | GuÃ­a para colaboradores.                                               | Explica cÃ³mo hacer PRs y commits.     |

ğŸ’¬ *Un repo sin documentaciÃ³n es como una casa sin puertas: nadie sabe por dÃ³nde entrar.*

---

### ğŸ§± 2. Commits profesionales

Usa **mensajes breves, consistentes y en presente**:

| Tipo de cambio  | Ejemplo de mensaje                          |
| --------------- | ------------------------------------------- |
| Nueva funciÃ³n   | `feat: agrega sistema de autenticaciÃ³n`     |
| CorrecciÃ³n      | `fix: corrige bug al crear usuario`         |
| DocumentaciÃ³n   | `docs: actualiza guÃ­a de instalaciÃ³n`       |
| RefactorizaciÃ³n | `refactor: simplifica lÃ³gica de validaciÃ³n` |
| Estilo          | `style: ajusta formato de cÃ³digo`           |
| Tests           | `test: agrega pruebas de login`             |

ğŸ’¡ Este formato (tipo: descripciÃ³n) es estÃ¡ndar en equipos grandes y compatible con **Conventional Commits**.

---

### ğŸ§° 3. Seguridad y respaldo

* **SSH**: usa llaves seguras en lugar de contraseÃ±as.
* **Forks**: trabaja en copias para no comprometer la rama principal.
* **Branches protegidas**: en GitHub, protege `main` para exigir revisiones antes de fusionar.
* **Respaldos locales**: clona tus repos crÃ­ticos en una segunda ubicaciÃ³n o disco externo.

---

### ğŸ§¹ 4. Limpieza y mantenimiento

Repite cada cierto tiempo:

```bash
git fetch --prune
git gc
git fsck
git reflog expire --expire=90.days.ago --all
```

ğŸ“Œ Con esto mantienes tu repositorio **optimizado y sin referencias viejas**.

---

### ğŸ’¼ 5. Mostrar tu trabajo (portafolio tÃ©cnico)

Para esta parte te tocarÃ¡ personalizar tu perfil de GitHub!, puedes verlo en las siguientes notas [github-essentials-notes.md](Ruta "Notas del curso enfocado a GitHub!")

* Crea un repositorio personal llamado **`<tu-usuario>`** en GitHub (por ejemplo, `Ssail-1`).
* PersonalÃ­zalo con un **README.md de perfil** (mostrarÃ¡ tu presentaciÃ³n en tu perfil pÃºblico).
* Incluye:

  * Breve biografÃ­a y objetivos.
  * Proyectos destacados.
  * Badges de tecnologÃ­as (desde [shields.io](https://shields.io/)).
  * EstadÃ­sticas y enlaces a tus redes profesionales.

ğŸ’¬ *Tu perfil de GitHub es tu nuevo currÃ­culum tÃ©cnico.*

---

### ğŸš€ 6. Preparar transiciÃ³n a la siguiente secciÃ³n: GitHub Tools

Esta parte no es necesarÃ­a al 100%, en [github-essentials-notes.md](Ruta "Notas del curso enfocado a GitHub!") podrÃ¡s descubir como configurar SSH que es lo unico que hace falta en este archivo, pero si te recomiendo tener una cuenta secundaria de github :D.

Antes de pasar a GitHub, asegÃºrate de tener:

âœ… SSH configurado y probado.
âœ… Tu cuenta principal ([`Ssail-1`](https://github.com/Ssail-1 "GitHub principal de Ssail")) como portfolio.
âœ… Tu cuenta secundaria ([`decktSsail`](https://github.com/decktSsail "GitHub secundario de Ssail")) para practicar forks y PRs.
âœ… Un repositorio con el que puedas experimentar como  ([`PlatziNotes`](https://github.com/Ssail-1/PlatziNotes "Repositorio de documentacion y notas de los cursos de Platzi")) actualizado con todo lo aprendido.  
âœ… Y claro conocimiento de los siguientes comandos:

* `git clone`, `git pull`, `git push`, `git fetch`
* `git add`, `git commit`, `git status`, `git diff`
* `git branch`, `git switch`, `git merge`, `git rebase`
* `git tag`, `git gc`, `git reflog`, `git clean`

De los cuales si tienes dudas, puedes regresar aqui siempre!

---

### ğŸ§  Diagrama resumen del mÃ³dulo Git

```mermaid
mindmap
  root((MÃ³dulo Git))
    Setup & Init
      ConfiguraciÃ³n global
      SSH Keys
    Stage & Snapshot
      git add
      git commit
    Branch & Merge
      Ramas
      Merge strategies
      Rebase
    Share & Update
      Pull
      Push
      Fetch
    Advanced
      Tags & Releases
      Maintenance
      Reflog & GC
```

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

### ğŸ’¬ ReflexiÃ³n final

> â€œDominar Git no es solo saber comandos, es **entender la historia del cÃ³digo**.â€
> Cada commit cuenta una parte de ti, de tus errores, tus mejoras y tus logros.
> Desde hoy, cada `git add` es una semilla de tu progreso ğŸŒ±.

[ğŸ”— Repositorio principal del proyecto](https://github.com/Ssail-1/PlatziNotes)

---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
---

âœ… **Con esto termina el mÃ³dulo de Git.**
El entorno estÃ¡ limpio, el conocimiento consolidado y estamos listos para dar el salto a la **SecciÃ³n II: GitHub â€” ColaboraciÃ³n y Herramientas en la Nube.**

---
---
---

<p align="center">
  <a href="#Ã­ndice">ğŸ” <b>Volver al Ãndice</b> ğŸ”</a>
</p>

---
> _â€œNo soy un experto, soy alguien que nunca dejarÃ¡ de intentarlo.â€_ â€” **Ssail**  
>
> _Creado con â¤ï¸ por **Ssail & Noa** â€” PlatziNotes Project 2025
>

[ğŸ”— Repositorio principal del proyecto](https://github.com/Ssail-1/PlatziNotes)

---